var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[0.746474, 0.553371, 0.255033, 0, 0.0658762], "total":[4708, 4358, 0, 1, 1], "name":"System", "max_resources":[854400, 1708800, 2713, 1518, 42720], "children":[{"name":"loop_pipeline", "compute_units":1, "type":"function", "total_percent":[0.746474, 0.553371, 0.255033, 0, 0.0658762], "total_kernel_resources":[4708, 4358, 0, 1, 1], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"64b wide with 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 20 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"20b wide with 0 elements."}]}, {"name":"Variable: \\n - \'acc\' (loop_pipeline2intel.cpp:24)", "type":"resource", "data":[7, 24, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":24}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 20 and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 20 width by 1 depth"}]}, {"name":"Variable: \\n - \'i\' (loop_pipeline2intel.cpp:23)", "type":"resource", "data":[14, 46, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":23}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 6 and depth 1"}, {"type":"text", "text":"1 register of width 32 and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 6 width by 1 depth,\\n1 reg, 32 width by 1 depth"}]}, {"name":"loop_pipeline.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[11, 455, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[11, 55, 0, 0, 0]}, {"name":"loop_pipeline2intel.cpp:30 > ac_int.h:2080 > \\nac_int.h:1428 > ac_int.h:670", "type":"resource", "data":[0, 400, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":30}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":2080}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":1428}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]]}]}, {"name":"Feedback", "type":"resource", "data":[14, 9, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"loop_pipeline2intel.cpp:21", "type":"resource", "data":[14, 9, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[1, 0, 0, 0, 0], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[12, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"24-bit Select", "type":"resource", "count":1, "data":[12, 0, 0, 0, 0]}]}, {"name":"loop_pipeline2intel.cpp:21", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"loop_pipeline2intel.cpp:30 > ac_int.h:2080 > \\nac_int.h:1428 > ac_int.h:670", "type":"resource", "data":[4100, 3520, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":30}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":2080}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":1428}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "children":[{"name":"Load", "type":"resource", "count":20, "data":[4100, 3520, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}, {"type":"brief", "text":"Local-pipelined LSU"}]}], "replace_name":"true"}]}]}, {"name":"loop_pipeline.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[6, 182, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[6, 162, 0, 0, 0]}, {"name":"loop_pipeline2intel.cpp:30 > ac_int.h:1516 > \\nac_int.h:675", "type":"resource", "data":[0, 10, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":30}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":1516}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":675}]]}, {"name":"loop_pipeline2intel.cpp:30 > ac_int.h:2080 > \\nac_int.h:1428 > ac_int.h:671", "type":"resource", "data":[0, 10, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":30}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":2080}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":1428}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":671}]]}]}, {"name":"Feedback", "type":"resource", "data":[44, 59, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[9, 28, 0, 0, 0]}, {"name":"loop_pipeline2intel.cpp:23", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":23}]]}, {"name":"loop_pipeline2intel.cpp:27", "type":"resource", "data":[33, 31, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":27}]]}, {"name":"loop_pipeline2intel.cpp:30 > ac_int.h:1516 > \\nac_int.h:675", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":30}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":1516}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":675}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[18, 27, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[4, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"24-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}]}, {"name":"loop_pipeline2intel.cpp:27", "type":"resource", "data":[49, 2, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":27}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"6-bit Integer Add", "type":"resource", "count":1, "data":[6, 0, 0, 0, 0]}, {"name":"6-bit Integer Compare", "type":"resource", "count":1, "data":[9, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"loop_pipeline2intel.cpp:30 > ac_int.h:1516 > \\nac_int.h:675", "type":"resource", "data":[26, 0, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":30}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":1516}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":675}]], "children":[{"name":"20-bit Integer Add", "type":"resource", "count":1, "data":[10, 0, 0, 0, 0]}, {"name":"20-bit Select", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"loop_pipeline2intel.cpp:30 > ac_int.h:2080 > \\nac_int.h:1428 > ac_int.h:671", "type":"resource", "data":[390, 0, 0, 1, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":30}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":2080}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":1428}, {"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":671}]], "children":[{"name":"20-bit Integer Add", "type":"resource", "count":20, "data":[390, 0, 0, 0, 0]}, {"name":"20-bit Integer Multiply", "type":"resource", "count":1, "data":[0, 0, 0, 1, 0]}], "replace_name":"true"}]}]}, {"name":"loop_pipeline.B3", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[2, 24, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[2, 24, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[6, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[6, 8, 0, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"loop_pipeline2intel.cpp:35", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":35}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}]}';
var area_srcJSON='{"max_resources":[854400,1708800,2713,1518,42720],"name":"System","children":[{"debug":[[{"filename":"loop_pipeline2intel.cpp","line":23}]],"total_kernel_resources":[4708,4358,0,1,1],"name":"loop_pipeline","data":[4708,4358,0,1,1],"children":[{"name":"Data control overhead","type":"resource","data":[83,103,0,0,1],"details":[{"text":"Feedback+Cluster logic","type":"brief"}]},{"name":"Component call","type":"resource","data":[0,0,0,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"64b wide with 0 elements.","type":"brief"}]},{"name":"Component return","type":"resource","data":[0,0,0,0,0],"details":[{"text":"Stream implemented 20 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"20b wide with 0 elements.","type":"brief"}]},{"name":"Variable: \\n - \'acc\' (loop_pipeline2intel.cpp:24)","type":"resource","data":[7,24,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 20 and depth 1","type":"text"},{"text":"Register,\\n1 reg, 20 width by 1 depth","type":"brief"}]},{"name":"Variable: \\n - \'i\' (loop_pipeline2intel.cpp:23)","type":"resource","data":[14,46,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 6 and depth 1","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"},{"text":"Register,\\n1 reg, 6 width by 1 depth,\\n1 reg, 32 width by 1 depth","type":"brief"}]},{"name":"No Source Line","data":[35,241,0,0,0],"type":"resource","children":[{"count":3,"name":"State","debug":[[{"filename":"","line":0}]],"type":"resource","data":[19,241,0,0,0]},{"count":2,"debug":[[{"filename":"","line":0}]],"name":"24-bit Select","data":[16,0,0,0,0],"type":"resource"}]},{"debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"name":"loop_pipeline2intel.cpp:30","data":[4516,3940,0,1,0],"type":"resource","children":[{"replace_name":true,"name":"loop_pipeline2intel.cpp:30 > ac_int.h:2080 > \\nac_int.h:1428 > ac_int.h:670","debug":[[{"filename":"loop_pipeline2intel.cpp","line":30},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":2080},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":1428},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":670}]],"type":"resource","data":[4100,3920,0,0,0],"children":[{"count":1,"name":"State","debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"type":"resource","data":[0,400,0,0,0]},{"count":20,"debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"name":"Load","data":[4100,3520,0,0,0],"type":"resource"}]},{"debug":[[{"filename":"loop_pipeline2intel.cpp","line":30},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":1516},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":675}]],"name":"loop_pipeline2intel.cpp:30 > ac_int.h:1516 > \\nac_int.h:675","replace_name":true,"children":[{"count":1,"name":"State","debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"type":"resource","data":[0,10,0,0,0]},{"count":1,"debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"name":"20-bit Integer Add","data":[10,0,0,0,0],"type":"resource"},{"count":1,"debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"name":"20-bit Select","data":[16,0,0,0,0],"type":"resource"}],"data":[26,10,0,0,0],"type":"resource"},{"replace_name":true,"name":"loop_pipeline2intel.cpp:30 > ac_int.h:2080 > \\nac_int.h:1428 > ac_int.h:671","debug":[[{"filename":"loop_pipeline2intel.cpp","line":30},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":2080},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":1428},{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h","line":671}]],"type":"resource","data":[390,10,0,1,0],"children":[{"count":1,"name":"State","debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"type":"resource","data":[0,10,0,0,0]},{"count":20,"debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"name":"20-bit Integer Add","data":[390,0,0,0,0],"type":"resource"},{"count":1,"debug":[[{"filename":"loop_pipeline2intel.cpp","line":30}]],"name":"20-bit Integer Multiply","data":[0,0,0,1,0],"type":"resource"}]}]},{"name":"loop_pipeline2intel.cpp:21","debug":[[{"filename":"loop_pipeline2intel.cpp","line":21}]],"replace_name":"true","type":"resource","data":[1,0,0,0,0],"children":[{"count":1,"name":"Stream Read","debug":[[{"filename":"loop_pipeline2intel.cpp","line":21}]],"type":"resource","data":[1,0,0,0,0]}]},{"name":"loop_pipeline2intel.cpp:27","debug":[[{"filename":"loop_pipeline2intel.cpp","line":27}]],"replace_name":"true","type":"resource","data":[49,2,0,0,0],"children":[{"count":1,"name":"1-bit And","debug":[[{"filename":"loop_pipeline2intel.cpp","line":27}]],"type":"resource","data":[1,1,0,0,0]},{"count":1,"name":"1-bit Or","debug":[[{"filename":"loop_pipeline2intel.cpp","line":27}]],"type":"resource","data":[1,0,0,0,0]},{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"loop_pipeline2intel.cpp","line":27}]],"type":"resource","data":[32,0,0,0,0]},{"count":1,"name":"6-bit Integer Add","debug":[[{"filename":"loop_pipeline2intel.cpp","line":27}]],"type":"resource","data":[6,0,0,0,0]},{"count":1,"name":"6-bit Integer Compare","debug":[[{"filename":"loop_pipeline2intel.cpp","line":27}]],"type":"resource","data":[9,1,0,0,0]}]},{"name":"loop_pipeline2intel.cpp:35","debug":[[{"filename":"loop_pipeline2intel.cpp","line":35}]],"replace_name":"true","type":"resource","data":[3,2,0,0,0],"children":[{"count":1,"name":"Stream Write","debug":[[{"filename":"loop_pipeline2intel.cpp","line":35}]],"type":"resource","data":[3,2,0,0,0]}]}],"total_percent":[0.746474,0.553371,0.255033,0,0.0658762],"type":"function","details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"compute_units":1}],"data":[4708,4358,0,1,1],"total_percent":[0.746474,0.553371,0.255033,0,0.0658762],"total":[4708,4358,0,1,1],"debug_enabled":"true","columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"loop_pipeline", "children":[{"type":"bb", "id":3, "name":"loop_pipeline.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"loop_pipeline.B1.start", "children":[{"type":"inst", "id":7, "name":"Stream Read", "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"2", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":9, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":10, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":11, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":12, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":13, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":14, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":15, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":16, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":17, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":18, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":19, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":20, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":21, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":22, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":23, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":24, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":25, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":26, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":27, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":28, "name":"Load", "debug":[[{"filename":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "line":670}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"A", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":31, "name":"loop", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"34"}]}, {"type":"inst", "id":32, "name":"end", "details":[{"type":"table", "Start Cycle":"34", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"34", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":5, "name":"loop_pipeline.B2", "details":[{"type":"table", "Latency":"9", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"", "Loops To":"5"}]}, {"type":"bb", "id":6, "name":"loop_pipeline.B3", "children":[{"type":"inst", "id":29, "name":"Stream Write", "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":35}]], "details":[{"type":"table", "Width":"20 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":33, "name":"begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":34, "name":"loop end", "details":[{"type":"table", "Start Cycle":"1", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"1", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}]}, {"type":"memtype", "id":1, "name":"System Memory", "children":[{"type":"memsys", "id":36, "name":"0", "details":[{"type":"table", "Number of banks":"1", "Arguments from loop_pipeline":"A"}]}]}, {"type":"stream", "id":8, "name":"do", "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":30, "name":"return", "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]], "details":[{"type":"table", "Width":"20 bits", "Depth":"0", "Bits per symbol":"20 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"interface", "id":35, "name":"A", "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"loop_pipeline"}]}], "links":[{"from":8, "to":7}, {"from":29, "to":30}, {"from":35, "to":7}, {"from":34, "to":31}, {"from":3, "to":31}, {"from":7, "to":32}, {"from":9, "to":32}, {"from":10, "to":32}, {"from":11, "to":32}, {"from":12, "to":32}, {"from":13, "to":32}, {"from":14, "to":32}, {"from":15, "to":32}, {"from":16, "to":32}, {"from":17, "to":32}, {"from":18, "to":32}, {"from":19, "to":32}, {"from":20, "to":32}, {"from":21, "to":32}, {"from":22, "to":32}, {"from":23, "to":32}, {"from":24, "to":32}, {"from":25, "to":32}, {"from":26, "to":32}, {"from":27, "to":32}, {"from":28, "to":32}, {"from":5, "to":5}, {"from":32, "to":5}, {"from":5, "to":33}, {"from":29, "to":34}, {"from":31, "to":7}, {"from":7, "to":9}, {"from":7, "to":10}, {"from":7, "to":11}, {"from":7, "to":12}, {"from":7, "to":13}, {"from":7, "to":14}, {"from":7, "to":15}, {"from":7, "to":16}, {"from":7, "to":17}, {"from":7, "to":18}, {"from":7, "to":19}, {"from":7, "to":20}, {"from":7, "to":21}, {"from":7, "to":22}, {"from":7, "to":23}, {"from":7, "to":24}, {"from":7, "to":25}, {"from":7, "to":26}, {"from":7, "to":27}, {"from":7, "to":28}, {"from":33, "to":29}, {"from":36, "to":25}, {"from":36, "to":10}, {"from":36, "to":13}, {"from":36, "to":16}, {"from":36, "to":28}, {"from":36, "to":19}, {"from":36, "to":22}, {"from":36, "to":27}, {"from":36, "to":11}, {"from":36, "to":14}, {"from":36, "to":23}, {"from":36, "to":17}, {"from":36, "to":20}, {"from":36, "to":12}, {"from":36, "to":18}, {"from":36, "to":24}, {"from":36, "to":9}, {"from":36, "to":21}, {"from":36, "to":26}, {"from":36, "to":15}]}';
var lmvJSON='{"nodes":[{"type":"interface", "id":35, "name":"A", "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"loop_pipeline"}]}], "links":[]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Bottleneck", "Details"], "children":[{"name":"Component: loop_pipeline", "data":["", "", ""], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}], "children":[{"name":"loop_pipeline.B1.start", "data":["Yes", ">=1", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Run simulation to verify component\'s dynamic II. Use the %L report to view results. II is an approximation due to variable inner loop trip count.", "links":[{"view":"Verification statistics"}]}], "children":[{"name":"loop_pipeline.B2", "data":["Yes", "1", "n/a"], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":27}]], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":29}]], "details":[{"type":"brief", "text":"Auto-unrolled"}, {"type":"text", "text":"Auto-unrolled"}], "children":[]}]}]}]}]}';
var summaryJSON='{"estimatedResources":{"name":"Estimated Resource Usage", "columns":["Component Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"loop_pipeline", "data":[4708, 4358, 0, 1, 1], "debug":[[{"filename":"loop_pipeline2intel.cpp", "line":21}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[4708, 4358, 0, 1, 1], "data_percent":[0.55103, 0.255033, 0, 0.0658762, 0.744503]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[854400, 1708800, 2713, 1518, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"classes":["info-table"],"name":"Project Name","data":["./test-fpga"]},{"name":"Target Family, Device","data":["Arria10, 10AX115U1F45I1SG"]},{"name":"i++ Version","data":["18.1.0 Build 222"]},{"name":"Quartus Version","data":["18.1.0 Build 222 Pro"]},{"name":"Command","data":["i++ loop_pipeline2intel.cpp loop_pipeline_test2intel.cpp -v --fpc --fp-relaxed --simulator none -march=Arria10 -o test-fpga"]},{"name":"Reports Generated At","data":["Thu Nov  9 21:08:15 2023"]}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{"name":"Quartus Fit Summary","children":[{"name":"Run Quartus compile to populate this section. See details for more information.","details":[{"text":"This section contains a summary of the area and fmax data generated by compiling the components through Quartus. \\nTo generate the data, run a Quartus compile on the project created for this design. To run the Quartus compile:\\n  1) Change to the quartus directory (./test-fpga.prj/quartus)\\n  2) quartus_sh --flow compile quartus_compile\\n","type":"text"}]}]}}';
var fileJSON=[{"path":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "name":"ac_int.h", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/ac_int.h", "content":"/**************************************************************************\012 *                                                                        *\012 *  Algorithmic C (tm) Datatypes                                          *\012 *                                                                        *\012 *  Software Version: 3.7                                                 *\012 *                                                                        *\012 *  Release Date    : Wed Jun  1 13:21:52 PDT 2016                        *\012 *  Release Type    : Production Release                                  *\012 *  Release Build   : 3.7.0                                               *\012 *                                                                        *\012 *  Copyright 2004-2016, Mentor Graphics Corporation,                     *\012 *                                                                        *\012 *  All Rights Reserved.                                                  *\012 *                                                                        *\012 **************************************************************************\012 *  Licensed under the Apache License, Version 2.0 (the \"License\");       *\012 *  you may not use this file except in compliance with the License.      *\012 *  You may obtain a copy of the License at                               *\012 *                                                                        *\012 *      http://www.apache.org/licenses/LICENSE-2.0                        *\012 *                                                                        *\012 *  Unless required by applicable law or agreed to in writing, software   *\012 *  distributed under the License is distributed on an \"AS IS\" BASIS,     *\012 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       *\012 *  implied.                                                              *\012 *  See the License for the specific language governing permissions and   *\012 *  limitations under the License.                                        *\012 **************************************************************************\012 *                                                                        *\012 *  This file was modified by the Intel High Level Design team to         *\012 *  generate efficient hardware for the Intel High Level Synthesis        *\012 *  compiler. The API remains the same as defined by Mentor Graphics      *\012 *  in the documentation for ac_int.h                                     *\012 *                                                                        *\012 *************************************************************************/\012\012/*\012//  Source:          ac_int.h\012//  Description:     fast arbitrary-length bit-accurate integer types:\012//                     - unsigned integer of length W:  ac_int<W,false>\012//                     - signed integer of length W:  ac_int<W,true>\012//  Original Author: Andres Takach, Ph.D.\012//  Modified by:     Vince Bridgers, Thor Thayer, Ajaykumar Kannan\012//\012//  Notes:\012//   - Compiler support: Works with the Intel i++ compiler. For g++, use the\012//                       original ac_int.h header file.\012//\012//   - Most frequent migration issues:\012//      - need to cast to common type when using question mark operator:\012//          (a < 0) ? -a : a;  // a is ac_int<W,true>\012//        change to:\012//          (a < 0) ? -a : (ac_int<W+1,true>) a;\012//        or\012//          (a < 0) ? (ac_int<W+1,false>) -a : (ac_int<W+1,false>) a;\012//\012//      - left shift is not arithmetic (\"a<<n\" has same bitwidth as \"a\")\012//          ac_int<W+1,false> b = a << 1;  // a is ac_int<W,false>\012//        is not equivalent to b=2*a. In order to get 2*a behavior change to:\012//          ac_int<W+1,false> b = (ac_int<W+1,false>)a << 1;\012//\012//      - only static length read/write slices are supported:\012//         - read:  x.slc<4>(k) => returns ac_int for 4-bit slice x(4+k-1 DOWNTO k)\012//         - write: x.set_slc(k,y) = writes bits of y to x starting at index k\012*/\012\012#ifndef __ALTR_AC_INT_H\012#define __ALTR_AC_INT_H\012\012#define AC_VERSION 3\012#define AC_VERSION_MINOR 7\012\012#ifndef __cplusplus\012#error C++ is required to include this header file\012#endif\012\012#if __cplusplus < 201402L\012#error The C++14 standard or newer is required to include this header file\012#endif\012\012// for safety\012#if (defined(W) || defined(I) || defined(S) || defined(W2) || defined(I2) || defined(S2))\012#error One or more of the following is defined: W, I, S, W2, I2, S2. Definition conflicts with their usage as template parameters.\012#error DO NOT use defines before including third party header files.\012#endif\012\012#if (defined(true) || defined(false))\012#error One or more of the following is defined: true, false. They are keywords in C++ of type bool. Defining them as 1 and 0, may result in subtle compilation problems.\012#error DO NOT use defines before including third party header files.\012#endif\012\012#ifndef __ASSERT_H__\012#define __ASSERT_H__\012#include <assert.h>\012#endif\012#include <limits>\012#ifndef AC_USER_DEFINED_ASSERT\012#if defined (__linux__)\012#include <iostream>\012#endif // linux\012#include <stdio.h>\012#else\012#if defined (__linux__)\012#include <ostream>\012#endif // linux\012#endif\012#include <algorithm>\012#include <HLS/math.h>\012#include <string>\012#include <vector>\012\012// __HLS_CONSTEXPR__ is defined as constexpr as long as no DEBUG flag is\012// enabled.\012#if defined(DEBUG_AC_INT_ERROR) || defined(DEBUG_AC_INT_WARNING)\012#define __HLS_CONSTEXPR__\012#pragma message (\"using ac_int debug macros (DEBUG_AC_INT_WARNING/DEBUG_AC_INT_ERROR) may result in performance degradation when compiling for FPGA.\")\012#else\012#define __HLS_CONSTEXPR__ constexpr\012#define __HLS_USE_CONSTEXPR__\012#endif\012\012#ifdef __AC_NAMESPACE\012namespace __AC_NAMESPACE {\012#endif\012\012#define AC_MAX(a,b) ((a) > (b) ? (a) : (b))\012#define AC_MIN(a,b) ((a) < (b) ? (a) : (b))\012#define AC_ABS(a) ((a) < 0 ? (-a) : (a))\012\012#if defined(_MSC_VER)\012typedef unsigned __int64 Ulong;\012typedef signed   __int64 Slong;\012#else\012typedef unsigned long long Ulong;\012typedef signed   long long Slong;\012#endif\012\012#define _STR_CONCAT_(a,b) a##b\012#define _STR_CONCAT(a,b) _STR_CONCAT_(a,b)\012#define ACINT_STATIC_ASSERT(X) \\\012  ;typedef int _STR_CONCAT(static_assert_line_, __LINE__)[(bool)(X) ? 1 : -1];\012\012enum ac_base_mode { AC_BIN=2, AC_OCT=8, AC_DEC=10, AC_HEX=16 };\012enum ac_special_val {AC_VAL_DC, AC_VAL_0, AC_VAL_MIN, AC_VAL_MAX, AC_VAL_QUANTUM};\012\012static bool warned_undef = false;\012\012template <int W, bool S> class ac_int;\012\012namespace ac_private {\012\012  template<int Bits> using ap_int = int __attribute__((__ap_int(Bits)));\012  template<unsigned int Bits> using ap_uint = unsigned int __attribute__((__ap_int(Bits)));\012\012  enum {long_w = std::numeric_limits<unsigned long>::digits};\012\012  // PRIVATE FUNCTIONS in namespace: for implementing ac_int/ac_fixed\012\012  inline double mgc_floor(double d) { return floor(d); }\012\012  #define AC_ASSERT(cond, msg) ac_private::ac_assert(cond, __FILE__, __LINE__, msg)\012  inline void ac_assert(bool condition, const char *file=0, int line=0, const char *msg=0) {\012  #ifdef HLS_X86\012    #ifndef AC_USER_DEFINED_ASSERT\012    if(!condition) {\012#if defined (__linux__)\012      std::cerr << \"Assert\";\012      if(file)\012        std::cerr << \" in file \" << file << \":\" << line;\012      if(msg)\012        std::cerr << \" \" << msg;\012      std::cerr << std::endl;\012#else\012      fprintf(stderr, \"Assert\");\012      if (file)\012        fprintf(stderr, \" in file %s:%d\", file, line);\012      if (msg)\012        fprintf(stderr, \" %s\", msg);\012      fprintf(stderr, \"\\n\");\012#endif // linux\012      assert(0);\012    }\012    #else\012    AC_USER_DEFINED_ASSERT(condition, file, line, msg);\012    #endif\012  #endif\012  }\012\012  // helper structs for statically computing log2 like functions (nbits, log2_floor, log2_ceil)\012  //   using recursive templates\012  template<unsigned char N>\012  struct s_N {\012    template<unsigned X>\012    struct s_X {\012      enum {\012        X2 = X >> N,\012        N_div_2 = N >> 1,\012        nbits = X ? (X2 ? N + (int) s_N<N_div_2>::template s_X<X2>::nbits : (int) s_N<N_div_2>::template s_X<X>::nbits) : 0\012      };\012    };\012  };\012  template<> struct s_N<0> {\012    template<unsigned X>\012    struct s_X {\012      enum {nbits = !!X };\012    };\012  };\012\012  template<int N>\012  inline double ldexpr32(double d) {\012    double d2 = d;\012    if(N < 0)\012      for(int i=0; i < -N; i++)\012        d2 /= (Ulong) 1 << 32;\012    else\012      for(int i=0; i < N; i++)\012        d2 *= (Ulong) 1 << 32;\012    return d2;\012  }\012  template<> inline double ldexpr32<0>(double d) { return d; }\012  template<> inline double ldexpr32<1>(double d) { return d * ((Ulong) 1 << 32); }\012  template<> inline double ldexpr32<-1>(double d) { return d / ((Ulong) 1 << 32); }\012  template<> inline double ldexpr32<2>(double d) { return (d * ((Ulong) 1 << 32)) * ((Ulong) 1 << 32); }\012  template<> inline double ldexpr32<-2>(double d) { return (d / ((Ulong) 1 << 32)) / ((Ulong) 1 << 32); }\012\012  template<int N>\012  inline double ldexpr(double d) {\012    return ldexpr32<N/32>( N < 0 ? d/( (unsigned) 1 << (-N & 31)) : d * ( (unsigned) 1 << (N & 31)));\012  }\012\012  template<int N>\012  inline double ldexpr1(double d) {\012    return  N < 0 ? d/( (unsigned) 1 << (-N)) : d * ( (unsigned) 1 << (N));\012  }\012\012  // Xn-1, Xn-2, Xn-3, Xn-4, ...X(I+W-1)..XI.., X2, X1, X0\012  // Returns ap_uint<W> using:  |---------| bits from value.\012  template<int W, int I, int N>\012  constexpr ap_uint<W> bit_slc(ap_uint<N> value) {\012    ACINT_STATIC_ASSERT(N >= W);\012    constexpr int shift_v = AC_MIN(I, N-1);\012    ap_uint<N> op = (value >> (shift_v ));\012    ap_uint<W> r = op; \012    return r;\012  }\012\012  // Xn-1, Xn-2, Xn-3, Xn-4, ...X(I+W-1)..XI.., X2, X1, X0\012  // Returns ap_int<W> using:   |---------| bits from value.\012  template<int W, int I, int N>\012  constexpr ap_int<W> bit_slc(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return (ap_uint<W>)(bit_slc<W, I, N>(v));\012  }\012\012  template<int N>\012  constexpr bool ap_less_zero(ap_uint<N>){\012    return false;\012  }\012\012  template<int N>\012  constexpr bool ap_less_zero(ap_int<N> value){\012    return value < 0;\012  }\012\012  // if bits [0, B-1] all 0s\012  template<int B, int N>\012  constexpr bool ap_equal_zeros_to(ap_uint<N> value) {\012    ap_uint<B> v = bit_slc<B, 0, N>(value);\012    return v == 0;\012  }\012\012  template<int B, int N>\012  constexpr bool ap_equal_zeros_to(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_zeros_to<B, N>(v);\012  }\012\012  // if bits [0, B-1] all 0s\012  template<int B, int N>\012  constexpr bool ap_equal_ones_to(ap_uint<N> value) {\012    ACINT_STATIC_ASSERT(N >= B);\012    if(!B) return true;\012    constexpr int B1 = AC_MAX(B, 1);\012    ap_uint<B1> v = bit_slc<B1, 0, N>(value);\012    return (~v) == 0;\012  }\012\012  template<int B, int N>\012  constexpr bool ap_equal_ones_to(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_ones_to<B, N>(v);\012  }\012\012  // if bits [B, N-1] are all ones\012  template<int B, int N>\012  constexpr bool ap_equal_zeros_from(ap_uint<N> value) {\012    constexpr int L = AC_MAX(N - B, 1);\012    ap_uint<L> v = bit_slc<L, B, N>(value);\012    return v == 0;\012  }\012\012  template<int B, int N>\012  constexpr bool ap_equal_zeros_from(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_zeros_from<B, N>(v);\012  }\012\012  template<int B, int N>\012  constexpr bool ap_equal_ones_from(ap_uint<N> value) {\012    constexpr int L = AC_MAX(N - B, 1);\012    ap_uint<L> v = bit_slc<L, B, N>(value);\012    return (~v) == 0;\012  }\012\012  template<int B, int N>\012  constexpr bool ap_equal_ones_from(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_ones_from<B, N>(v);\012  }\012\012  // Build an ap_int from double d, value is d * 2 ^ N\012  // Notice: in ref, it's d * 2 ^ (32 * N)\012  template<int N, bool S>\012  inline void ap_conv_from_fraction(double d, ap_int<N> & r, bool *qb, bool *rbits, bool *o, int *io) {\012    bool b = d < 0;\012    double d2 = b ? -d : d; \012    double dfloor = mgc_floor(d2);\012    *o = dfloor != 0.0;  \012    d2 = d2 - dfloor;\012    const int shift_amount = N  + 1;\012    const int container_length = (shift_amount + 31)/32 * 32 + 1;\012    ap_int<N + 1> tb;\012    ap_uint<container_length> k1;\012    const Ulong u64_1 = 1;\012    //for performance purpose, manually unroll the loop when shift_amount <= 64\012    if(shift_amount <= 32){\012      d2 *= u64_1 << shift_amount;\012      k1 = (unsigned int)floor(d2);\012      tb = b ? ~k1 : k1;\012      d2 -= k1;\012    }\012    else if(shift_amount <= 64){\012      d2 *= u64_1 << 32;\012      unsigned int temp = (unsigned int)floor(d2);\012      k1 = temp;\012      d2 -= temp;\012      const int shift_next = AC_MAX(shift_amount - 32, 0);\012      d2 *= u64_1 << shift_next;\012      temp = (unsigned int)floor(d2);\012      k1 <<= shift_next;\012      k1 |= temp;\012      d2 -= temp;\012      tb = b? ~k1 : k1;\012    }\012    else {\012      k1 = 0;\012      int to_shift = shift_amount;\012      unsigned int temp;\012      while(to_shift >= 32){\012        to_shift -= 32;\012        d2 *= u64_1 << 32;\012        temp = (unsigned int)floor(d2);\012        k1 <<= 32;\012        k1 |= temp;\012        d2 -= temp;\012      }\012      const int shift_next = AC_MAX(to_shift % 32, 0);\012      d2 *= u64_1 << shift_next;\012      temp = (unsigned int)floor(d2);\012      k1 <<= shift_next;\012      k1 |= temp;\012      d2 -= temp;\012      tb = b? ~k1 : k1;\012    }\012\012    r = tb;\012    d2 *= 2;\012    bool k = (int(d2)) != 0; //math\012    d2 -= k ? 1.0 : 0.0;\012    *rbits = d2 != 0.0;\012    *qb = (b && *rbits) ^ k;\012    if(b && !*rbits && !*qb){\012      r +=1;\012    }\012    *io = 0;\012    bool cond1 = !ap_equal_zeros_from<N>(k1);\012    if(!S){\012      if(b) *io = -1;\012      else if(cond1) *io = 1;   \012    } else{\012      //             |    | N - 1 bits digi_bits\012      //             |Sbit|\012      // cond1: not 0|X   |.........: inner overflow\012      // cond2      0|1   |000000000: not inner overflow, *io = -2\012      // cond3:     0|1   |not all 0: inner overflow\012      if(b){\012        bool sign_bit = bit_slc<1, N-1>(k1);\012        bool digi_bits_zero = ap_equal_zeros_to<N-1>(k1);\012        if(cond1) *io = -1; // cond1\012        else if(sign_bit){\012          if(digi_bits_zero) *io = -2; // cond2\012          else *io = -1; // cond3\012        }\012      } else{\012        if(!ap_equal_zeros_from<N-1>(k1)) *io = 1;\012      }\012    }\012    *o |= b ^ (( tb < 0) && S);      \012  }\012  template<int N, bool S>\012  inline void ap_conv_from_fraction(double d, ap_uint<N> & r, bool *qb, bool *rbits, bool *o, int *io) { \012    ap_int< N > r1;\012    ap_conv_from_fraction<N, S>(d, r1, qb, rbits, o, io);\012    r = r1;\012  }\012\012  constexpr Ulong mult_u_u(int a, int b) {\012    return (Ulong) (unsigned) a * (Ulong) (unsigned) b;\012  }\012  constexpr Slong mult_u_s(int a, int b) {\012    return (Ulong) (unsigned) a * (Slong) (signed) b;\012  }\012  constexpr Slong mult_s_u(int a, int b) {\012    return (Slong) (signed) a * (Ulong) (unsigned) b;\012  }\012  constexpr Slong mult_s_s(int a, int b) {\012    return (Slong) (signed) a * (Slong) (signed) b;\012  }\012  constexpr void accumulate(Ulong a, Ulong &l1, Slong &l2) {\012    l1 += (Ulong) (unsigned) a;\012    l2 += a >> 32;\012  }\012  constexpr void accumulate(Slong a, Ulong &l1, Slong &l2) {\012    l1 += (Ulong) (unsigned) a;\012    l2 += a >> 32;\012  }\012\012  template<int N>\012  constexpr bool ap_uadd_carry(ap_uint<N> op, bool carry, ap_uint<N> & r) {\012    r += carry;\012    return carry && (r == 0);\012  }\012\012  template<int N>\012  constexpr bool ap_uadd_carry(ap_int<N> op, bool carry, ap_int<N> & r) {\012    ap_uint<N> ur = r;\012    bool ret =  ap_uadd_carry( (ap_uint<N>)(op), carry, ur);\012    r = ur;\012    return ret; \012  }\012\012  //Helper function for multiplication on x86\012  template <int N1, int N2>\012  constexpr ap_uint<N1 + N2> bit_multiply(ap_uint<N1> v1, ap_uint<N2> v2) {\012    ap_uint<N1 + N2 > x1 = v1;\012    ap_uint<N2 > x2 = v2;\012    \012    ap_uint<N1 + N2> r = 0;\012    while (x2 != 0) {\012      if (x2 & 1) {\012        r += x1;\012      }\012      x1 <<= 1;                 \012      x2 >>= 1;                 \012    }\012    return r;\012  }\012\012  //Helper function for pow on x86\012  template <int N, int P>\012  constexpr ap_uint<N * P> ap_int_pow(ap_uint<N> value) {\012    constexpr int Nr = N * P;\012    ap_uint<Nr> base = value;\012    ap_uint<Nr> r = 1;\012    int pow = P;\012    while (pow > 0){\012      if( pow % 2 == 0){\012        pow /= 2;\012        base = bit_multiply<Nr, Nr>(base, base);\012      } else {\012        pow -= 1;\012        r = bit_multiply<Nr, Nr>(r, base);\012        pow /= 2;\012        base = bit_multiply<Nr, Nr>(base, base);\012      }\012    }\012    return r;\012  }\012\012  //Helper function for large divisions on x86\012  template <int N>\012  constexpr ap_uint<N> bit_division(ap_uint<N> value, ap_uint<N> divisor, ap_uint<N> & remainder) {\012    ap_uint<N> quotient = 1;\012    ap_uint<N> tempdivisor = divisor;\012    if (value == tempdivisor) {\012      remainder = 0;\012      return 1;\012    } else if (value < tempdivisor) {\012      remainder = value;\012      return 0;\012    }\012    while ((tempdivisor << 1) <= value){\012      tempdivisor = tempdivisor << 1;\012      quotient = quotient << 1;\012    }\012    quotient = quotient + bit_division(value - tempdivisor, divisor, remainder);\012    return quotient;\012  }\012\012  template <int N>\012  constexpr ap_uint<N> bit_division(ap_uint<N> value, ap_uint<N> divisor) {\012    ap_uint<N> r = 0;\012    return bit_division<N>(value, divisor, r);\012  }\012\012  template <int N>\012  inline std::string to_string(ap_uint<N> value, int base) {\012    std::string buf = \"\";\012\012    if (base < 2 || base > 16) return buf;\012\012    enum { kMaxDigits = 35 };\012    buf.reserve(kMaxDigits);\012\012    const int N_bits = AC_MAX(N + 1, 5);\012    ap_uint<N_bits> quotient = value;\012    int mod;\012    ap_uint<N_bits> b = base;\012    do {\012      ap_uint<N_bits> r = 0;\012      quotient = bit_division<N_bits>(quotient, b, r);\012      mod = (int)(r);\012      buf += \"0123456789abcdef\"[ mod ];\012    } while (quotient);\012\012    std::reverse(buf.begin(), buf.end());\012    return buf;\012  }\012\012  template <int N>\012  inline std::string to_string_u(ap_uint<N> value, int base) {\012    return to_string(value,base);\012  }\012\012  template <int N>\012  inline std::string to_string(ap_int<N> value, int base) {\012    ap_int<N + 1> v = value;\012    if(value >= 0){\012      ap_uint<N + 1> t = v;\012      return to_string(t, base);\012    } else {\012      ap_uint<N + 1> t = -v;\012      return \"-\" + to_string(t, base);\012    }\012  }\012\012  template<int W, bool S> struct select_type {};\012\012  // The i++ flow type selections ...\012  template<int W>\012  struct select_type<W, true> {\012    typedef ap_int<W> type;\012  };\012\012  template<int W>\012  struct select_type<W, false> {\012    typedef ap_uint<W> type;\012  };\012\012  //////////////////////////////////////////////////////////////////////////////\012  //  Integer Vector class: iv\012  //////////////////////////////////////////////////////////////////////////////\012  template<int N, bool S>\012  class iv {\012  protected:\012    typedef typename select_type<N, S>::type actype;\012    actype value;\012  public:\012    template<int N2, bool S2> friend class iv;\012    \012    constexpr iv() {}\012    \012    template<int N2, bool S2>\012    constexpr iv(const iv<N2, S2> &b) : value(b.value){}\012    /* Note: char and short constructors are an extension to Calypto's\012       implementation to address the i++ default behaviour of not promoting\012       to integers. (these functions are not in Calypto's ac_int.h) */\012    constexpr iv(char t) : value(t) {}\012    constexpr iv(unsigned char t) : value(t) {}\012    constexpr iv(short t) : value(t) {}\012    constexpr iv(unsigned short t) : value(t) {}\012    constexpr iv(Slong t) : value(t) {}\012    constexpr iv(Ulong t) : value(t) {}\012    constexpr iv(int t) : value(t) {}\012    constexpr iv(unsigned int t) : value(t) {}\012    constexpr iv(long t) : value(t) {}\012    constexpr iv(unsigned long t) : value(t) {}\012    constexpr iv(double d) : value((actype) (long long)d) {}\012    constexpr iv(float d) : value((actype) (long long)d) {}\012\012    // Explicit conversion functions to C built-in types -------------\012    constexpr Slong to_int64() const {\012      return (Slong) value;\012    }\012    constexpr Ulong to_uint64() const {\012      return (Ulong) value;\012    }\012    inline double to_double() const {\012      volatile Slong t = (Slong) value;\012      return (double) (t);\012    }\012\012    std::string to_string(ac_base_mode mode) const {\012      return ac_private::to_string<N>(value, mode);\012    }\012\012    //BEGIN: debug functions for X86 flow\012    template<int N2, bool S2>\012    __HLS_CONSTEXPR__ void debug_within_range(const iv<N2, S2> &op2){\012    #if !defined(__HLS_USE_CONSTEXPR__)\012      enum {Nx = AC_MAX(N, N2 + 1) };\012      ap_int<N2 + 1> v = op2.value;\012      if(N2 + 1 <= N) return ;\012      // S -> S, check bits [N2 + 1, .. , N-1]\012      if(S){\012        if(ap_equal_ones_from<N - 1, N2 + 1>(v)) return ;\012        if(ap_equal_zeros_from<N - 1, N2 + 1>(v)) return ;\012      }\012      // S -> U, check bits [N2 + 1, .. , N]\012      else{\012        if(ap_equal_zeros_from<N, N2 + 1>(v)) return ;\012      }\012      #if defined (__linux__)\012      std::cout << \"warning: overflow, assign value \" \\\012      << ac_private::to_string(v, 10) \\\012      << \" to type ac_int<\" << N << \", \" << (S? \"true\" : \"false\") << \">\" \\\012      << std::endl;\012      #else\012      printf(\"warning: overflow, assign value %s to type ac_int<%d, %s>\\n\",\012        ac_private::to_string(v, 10).c_str(), N, S? \"true\" : \"false\");\012      #endif\012\012      #ifdef DEBUG_AC_INT_ERROR\012      AC_ASSERT(0, \"Assert due to overflow (DEBUG_AC_INT_ERROR)\");\012      #endif\012    #endif \012    }\012\012    __HLS_CONSTEXPR__ void debug_within_range(Ulong v){\012      debug_within_range(iv<64, false>(v));\012    }\012\012    __HLS_CONSTEXPR__ void debug_within_range(Slong v){\012      debug_within_range(iv<64, true>(v));\012    }\012    //END\012\012    // o: outer overflow\012    // io: inner overflow\012    // qb: qb\012    // rbits: r\012    inline void conv_from_fraction(double d, bool *qb, bool *rbits, bool *o, int *io) {\012      ap_conv_from_fraction<N, S>(d, value, qb, rbits, o, io);\012    }\012\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void mult(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      ACINT_STATIC_ASSERT(N2 <= 512);\012      ACINT_STATIC_ASSERT(Nr <= 512);\012      r.value = value;\012      r.value *= op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void add(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value += op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void sub(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value -= op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void div(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      ACINT_STATIC_ASSERT(N2 <= 64);\012      ACINT_STATIC_ASSERT(Nr <= 64);\012      typedef typename select_type<N2,S2>::type adivtype;\012      typedef typename select_type<Nr,Sr>::type bdivtype;\012      adivtype a = op2.value;\012      bdivtype b = value;\012      r.value = b/a;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void rem(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value %= op2.value;\012    }\012    constexpr void increment() {\012      value += 1;\012    }\012    constexpr void decrement() {\012      value -= 1;\012    }\012    template<int Nr, bool Sr>\012    constexpr void neg(iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value = -r.value;\012    }\012\012    // Shift Operators\012    template<int Nr, bool Sr>\012    constexpr void shift_l(unsigned op2, iv<Nr, Sr> &r) const {\012      if (op2 >= Nr) {\012        r.value = 0;\012      } else {\012        r.value = value;\012        r.value <<= op2;\012      }\012    }\012\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wtautological-compare\"\012// Avoid a clang compiler warning below by temporarily suppressing\012// a autological-compare warning to keep the compiler output\012// tidy for the customer.\012//\012// warning: comparison of unsigned expression < 0 is always false [-Wtautological-compare]\012//      } else if ( (op2 >= Nr) && Sr && (value < 0) ) {\012//                                        ~~~~~ ^ ~\012// Note that since this expression is evaluated at compile time, the compiler\012// will throw a warning in the case the expression is always 0.\012// So just suppress it.\012    template<int Nr, bool Sr>\012    constexpr void shift_l2(signed op2, iv<Nr, Sr> &r) const {\012      signed shift = AC_ABS(op2);\012      if (shift >= Nr) {\012        shift = Nr;\012      }\012\012      if (op2 > 0) {\012        if (shift == Nr) {\012          r.value = 0;\012        } else {\012          r.value = value;\012          r.value <<= shift;\012        }\012      } else {\012        if (shift == Nr) {\012          if (value < 0) {\012            r.value = -1;\012          } else {\012            r.value = 0;\012          }\012        } else {\012          r.value = value >> shift;\012        }\012      }\012    }\012#pragma clang diagnostic pop\012\012    template<int Nr, int Sr, int B>\012    constexpr void const_shift_l(iv<Nr, Sr> &r) const {\012      shift_l2<Nr, Sr>(B, r);\012    }\012\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wtautological-compare\"\012    template<int Nr, bool Sr>\012    constexpr void shift_r(unsigned op2, iv<Nr, Sr> &r) const {\012      if ( (op2 >= Nr) && ((Sr && (value > 0)) || !Sr) ) {\012        r.value = 0;\012      } else if ( (op2 >= Nr) && Sr && (value < 0) ) {\012        r.value = -1;\012      } else {\012          r.value = value >> op2;\012      }\012    }\012\012    template<int Nr, bool Sr>\012    constexpr void shift_r2(signed op2, iv<Nr, Sr> &r) const {\012      signed shift = AC_ABS(op2);\012      const int Ns = AC_MAX(Nr, N);\012      if (shift >= Ns) {\012          shift = Ns;\012      }\012      if (op2 > 0) {\012        if (shift == Ns) {\012          if (value < 0) {\012            r.value = -1;\012          } else {\012            r.value = 0;\012          }\012        } else {\012            r.value = value >> shift;\012        }\012      } else {\012        if (shift == Ns) {\012          r.value = 0;\012        } else {\012          r.value = value;\012          r.value <<= shift;\012        }\012      }\012    }\012#pragma clang diagnostic pop\012\012    template<int Nr, bool Sr, int B>\012    constexpr void const_shift_r(iv<Nr, Sr> &r) const {\012      shift_r2<Nr, Sr>(B, r);\012    }\012\012    template<int Nr, bool Sr>\012    constexpr void bitwise_complement(iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value = ~r.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void bitwise_and(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value &= op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void bitwise_or(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value |= op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    constexpr void bitwise_xor(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value ^= op2.value;\012    }\012    template<int N2, bool S2>\012    constexpr bool equal(const iv<N2, S2> &op2) const {\012      constexpr auto Sx = AC_MAX(N, N2);\012      ap_int<Sx+1> a = (ap_int<Sx+1>)value;\012      ap_int<Sx+1> b = (ap_int<Sx+1>)op2.value;\012      return (a == b);\012    }\012    template<int N2, bool S2>\012    constexpr bool greater_than(const iv<N2, S2> &op2) const {\012      constexpr auto Sx = AC_MAX(N, N2);\012      ap_int<Sx+1> a = (ap_int<Sx+1>)value;\012      ap_int<Sx+1> b = (ap_int<Sx+1>)op2.value;\012      return (a > b);\012    }\012    template<int N2, bool S2>\012    constexpr bool less_than(const iv<N2, S2> &op2) const {\012      enum {Sx = AC_MAX(N, N2) };\012      ap_int<Sx+1> a = (ap_int<Sx+1>)value;\012      ap_int<Sx+1> b = (ap_int<Sx+1>)op2.value;\012      return (a < b);\012    }\012    constexpr bool equal_zero() const {\012      actype zero = 0;\012      return (value == zero);\012    }\012\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wshift-count-overflow\"\012    template<int N2, bool S2>\012    void set_slc(unsigned lsb, int WS, const iv<N2, S2> &op2) {\012      AC_ASSERT(N2<=N, \"Bad usage: WS greater than length of slice\");\012      if(N2 == N){\012        value = op2.value;\012      }\012      else if (N2 <= N) {\012        iv<N,S> temp;\012        temp.value = (actype) op2.value;\012        temp.value <<= lsb;\012        // Compute AND mask\012        iv<N,S> mask;\012        mask.value = 1;\012        mask.value <<= N2;\012        mask.value -= 1;\012        mask.value <<= lsb;\012\012        mask.value = ~mask.value;\012        value &= mask.value;\012        value |= temp.value;\012      } else {\012        value = 0;\012      }\012    }\012#pragma clang diagnostic pop\012\012    unsigned leading_bits(bool bit) const {\012      return 0;\012    }\012\012    template <int Nr, bool Sr>\012    constexpr void reverse(iv<Nr, Sr> &r) const {\012      r.value = 0;\012      for (int i = 0; i < N; i++) {\012        r.value |= ((value >> i) & 1) << ((N - 1) -i);\012      }\012    }\012  }; // class iv, signed\012\012  /* TODO\012  template<> inline Slong iv<1>::to_int64() const { return v[0]; }\012  template<> inline Ulong iv<1>::to_uint64() const { return v[0]; }\012\012  template<> inline Slong iv<2>::to_int64() const {\012    return ((Ulong)v[1] << 32) | (Ulong) (unsigned) v[0];\012  }\012  template<> inline Ulong iv<2>::to_uint64() const {\012    return ((Ulong)v[1] << 32) | (Ulong) (unsigned) v[0];\012  }\012\012  template<> template<> inline void iv<1>::set_slc(unsigned lsb, int WS, const iv<1> &op2) {\012    v[0] ^= (v[0] ^ (op2.v[0] << lsb)) & (~(WS==32 ? 0 : ~0<<WS) << lsb);\012  }\012  template<> template<> inline void iv<2>::set_slc(unsigned lsb, int WS, const iv<1> &op2) {\012    Ulong l = to_uint64();\012    Ulong l2 = op2.to_uint64();\012    l ^= (l ^ (l2 << lsb)) & (~((~(Ulong)0)<<WS) << lsb);  // WS <= 32\012    *this = l;\012  }\012  template<> template<> inline void iv<2>::set_slc(unsigned lsb, int WS, const iv<2> &op2) {\012    Ulong l = to_uint64();\012    Ulong l2 = op2.to_uint64();\012    l ^= (l ^ (l2 << lsb)) & (~(WS==64 ? (Ulong) 0 : ~(Ulong)0<<WS) << lsb);\012    *this = l;\012  }\012  */\012\012  // add automatic conversion to Slong/Ulong depending on S and C\012  template<int N, bool S, bool C>\012  class iv_conv : public iv<N, S> {\012  protected:\012    constexpr iv_conv() {}\012    template<class T> constexpr iv_conv(const T& t) : iv<N, S>(t) {}\012  };\012\012  template<int N>\012  class iv_conv<N,false,true> : public iv<N, false> {\012  public:\012    constexpr operator Ulong () const { return iv<N, false>::to_uint64(); }\012  protected:\012    constexpr iv_conv() {}\012    template<class T> constexpr iv_conv(const T& t) : iv<N, false>(t) {}\012  };\012\012  template<int N>\012  class iv_conv<N,true,true> : public iv<N, true> {\012  public:\012    constexpr operator Slong () const { return iv<N, true>::to_int64(); }\012  protected:\012    constexpr iv_conv() {}\012    template<class T> constexpr iv_conv(const T& t) : iv<N, true>(t) {}\012  };\012\012  // Set default to promote to int as this is the case for almost all types\012  //  create exceptions using specializations\012  template<typename T>\012  struct c_prom {\012    typedef int promoted_type;\012  };\012  template<> struct c_prom<unsigned> {\012    typedef unsigned promoted_type;\012  };\012  template<> struct c_prom<long> {\012    typedef long promoted_type;\012  };\012  template<> struct c_prom<unsigned long> {\012    typedef unsigned long promoted_type;\012  };\012  template<> struct c_prom<Slong> {\012    typedef Slong promoted_type;\012  };\012  template<> struct c_prom<Ulong> {\012    typedef Ulong promoted_type;\012  };\012  template<> struct c_prom<float> {\012    typedef float promoted_type;\012  };\012  template<> struct c_prom<double> {\012    typedef double promoted_type;\012  };\012\012  template<typename T, typename T2>\012  struct c_arith {\012     // will error out for pairs of T and T2 that are not defined through specialization\012  };\012  template<typename T> struct c_arith<T,T> {\012    typedef T arith_conv;\012  };\012\012  #define C_ARITH(C_TYPE1, C_TYPE2) \\\012  template<> struct c_arith<C_TYPE1, C_TYPE2> { \\\012    typedef C_TYPE1 arith_conv; \\\012  }; \\\012  template<> struct c_arith<C_TYPE2, C_TYPE1> { \\\012    typedef C_TYPE1 arith_conv; \\\012  };\012\012  C_ARITH(double, float)\012  C_ARITH(double, int)\012  C_ARITH(double, unsigned)\012  C_ARITH(double, long)\012  C_ARITH(double, unsigned long)\012  C_ARITH(double, Slong)\012  C_ARITH(double, Ulong)\012  C_ARITH(float, int)\012  C_ARITH(float, unsigned)\012  C_ARITH(float, long)\012  C_ARITH(float, unsigned long)\012  C_ARITH(float, Slong)\012  C_ARITH(float, Ulong)\012\012  C_ARITH(Slong, int)\012  C_ARITH(Slong, unsigned)\012  C_ARITH(Ulong, int)\012  C_ARITH(Ulong, unsigned)\012\012  template<typename T>\012  struct map {\012    typedef T t;\012  };\012  template<typename T>\012  struct c_type_params {\012    // will error out for T for which this template struct is not specialized\012  };\012\012  template<typename T> inline const char *c_type_name() { return \"unknown\"; }\012  template<> inline const char *c_type_name<bool>() { return \"bool\";}\012  template<> inline const char *c_type_name<char>() { return \"char\";}\012  template<> inline const char *c_type_name<signed char>() { return \"signed char\";}\012  template<> inline const char *c_type_name<unsigned char>() { return \"unsigned char\";}\012  template<> inline const char *c_type_name<signed short>() { return \"signed short\";}\012  template<> inline const char *c_type_name<unsigned short>() { return \"unsigned short\";}\012  template<> inline const char *c_type_name<int>() { return \"int\";}\012  template<> inline const char *c_type_name<unsigned>() { return \"unsigned\";}\012  template<> inline const char *c_type_name<signed long>() { return \"signed long\";}\012  template<> inline const char *c_type_name<unsigned long>() { return \"unsigned long\";}\012  template<> inline const char *c_type_name<signed long long>() { return \"signed long long\";}\012  template<> inline const char *c_type_name<unsigned long long>() { return \"unsigned long long\";}\012  template<> inline const char *c_type_name<float>() { return \"float\";}\012  template<> inline const char *c_type_name<double>() { return \"double\";}\012\012  template<typename T> struct c_type;\012\012  template<typename T>\012  struct rt_c_type_T {\012    template<typename T2>\012    struct op1 {\012      typedef typename T::template rt_T< c_type<T2> >::mult mult;\012      typedef typename T::template rt_T< c_type<T2> >::plus plus;\012      typedef typename T::template rt_T< c_type<T2> >::minus2 minus;\012      typedef typename T::template rt_T< c_type<T2> >::minus minus2;\012      typedef typename T::template rt_T< c_type<T2> >::logic logic;\012      typedef typename T::template rt_T< c_type<T2> >::div2 div;\012      typedef typename T::template rt_T< c_type<T2> >::div div2;\012    };\012  };\012  template<typename T>\012  struct c_type {\012    typedef typename c_prom<T>::promoted_type c_prom_T;\012    struct rt_unary {\012      typedef c_prom_T neg;\012      typedef c_prom_T mag_sqr;\012      typedef c_prom_T mag;\012      template<unsigned N>\012      struct set {\012        typedef c_prom_T sum;\012      };\012    };\012    template<typename T2>\012    struct rt_T {\012      typedef typename rt_c_type_T<T2>::template op1<T>::mult mult;\012      typedef typename rt_c_type_T<T2>::template op1<T>::plus plus;\012      typedef typename rt_c_type_T<T2>::template op1<T>::minus minus;\012      typedef typename rt_c_type_T<T2>::template op1<T>::minus2 minus2;\012      typedef typename rt_c_type_T<T2>::template op1<T>::logic logic;\012      typedef typename rt_c_type_T<T2>::template op1<T>::div div;\012      typedef typename rt_c_type_T<T2>::template op1<T>::div2 div2;\012    };\012    inline static std::string type_name() {\012      std::string r = c_type_name<T>();\012      return r;\012    }\012\012  };\012  // with T == c_type\012  template<typename T>\012  struct rt_c_type_T< c_type<T> > {\012    typedef typename c_prom<T>::promoted_type c_prom_T;\012    template<typename T2>\012    struct op1 {\012      typedef typename c_prom<T2>::promoted_type c_prom_T2;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv mult;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv plus;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv minus;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv minus2;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv logic;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv div;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv div2;\012    };\012  };\012\012  #define C_TYPE_MAP(C_TYPE) \\\012  template<> struct map<C_TYPE> { \\\012    typedef c_type<C_TYPE> t; \\\012  };\012\012  #define C_TYPE_PARAMS(C_TYPE, WI, SI) \\\012  template<> struct c_type_params<C_TYPE> { \\\012    enum { W = WI, I = WI, E = 0, S = SI, floating_point = 0 }; \\\012  };\012\012  #define C_TYPE_MAP_INT(C_TYPE, WI, SI) \\\012    C_TYPE_MAP(C_TYPE) \\\012    C_TYPE_PARAMS(C_TYPE, WI, SI)\012\012  #define C_TYPE_MAP_FLOAT(C_TYPE, FP, WFP, IFP, EFP) \\\012  C_TYPE_MAP(C_TYPE) \\\012  template<> struct c_type_params<C_TYPE> { \\\012    enum { W = WFP, I = IFP, E = EFP, S = true, floating_point = FP }; \\\012  };\012\012  C_TYPE_MAP_INT(bool, 1, false)\012  C_TYPE_MAP_INT(char, 8, true)\012  C_TYPE_MAP_INT(signed char, 8, true)\012  C_TYPE_MAP_INT(unsigned char, 8, false)\012  C_TYPE_MAP_INT(signed short, 16, true)\012  C_TYPE_MAP_INT(unsigned short, 16, false)\012  C_TYPE_MAP_INT(signed int, 32, true)\012  C_TYPE_MAP_INT(unsigned int, 32, false)\012  C_TYPE_MAP_INT(signed long, ac_private::long_w, true)\012  C_TYPE_MAP_INT(unsigned long, ac_private::long_w, false)\012  C_TYPE_MAP_INT(signed long long, 64, true)\012  C_TYPE_MAP_INT(unsigned long long, 64, false)\012  C_TYPE_MAP_FLOAT(float, 1, 25, 1, 8)\012  C_TYPE_MAP_FLOAT(double, 2, 54, 1, 11)\012\012  #undef C_TYPE_INT\012  #undef C_TYPE_PARAMS\012  #undef C_TYPE_FLOAT\012  #undef C_TYPE_MAP\012\012  // specializations for following struct declared/defined after definition of ac_int\012  template<typename T>\012  struct rt_ac_int_T {\012    template<int W, bool S>\012    struct op1 {\012      typedef typename T::template rt_T< ac_int<W,S> >::mult mult;\012      typedef typename T::template rt_T< ac_int<W,S> >::plus plus;\012      typedef typename T::template rt_T< ac_int<W,S> >::minus2 minus;\012      typedef typename T::template rt_T< ac_int<W,S> >::minus minus2;\012      typedef typename T::template rt_T< ac_int<W,S> >::logic logic;\012      typedef typename T::template rt_T< ac_int<W,S> >::div2 div;\012      typedef typename T::template rt_T< ac_int<W,S> >::div div2;\012    };\012  };\012}\012\012namespace ac {\012  // compiler time constant for log2 like functions\012  template<unsigned X>\012  struct nbits {\012    enum { val = ac_private::s_N<16>::s_X<X>::nbits };\012  };\012\012  template<unsigned X>\012  struct log2_floor {\012    enum { val = nbits<X>::val - 1 };\012  };\012\012  // log2 of 0 is not defined: generate compiler error\012  template<> struct log2_floor<0> {};\012\012  template<unsigned X>\012  struct log2_ceil {\012    enum { lf = log2_floor<X>::val, val = (X == (1 << lf) ? lf : lf+1) };\012  };\012\012  // log2 of 0 is not defined: generate compiler error\012  template<> struct log2_ceil<0> {};\012\012  template<int LowerBound, int UpperBound>\012  struct int_range {\012    enum { l_s = LowerBound < 0, u_s = UpperBound < 0,\012           signedness = l_s || u_s,\012           l_nbits = nbits<AC_ABS(LowerBound+l_s)+l_s>::val,\012           u_nbits = nbits<AC_ABS(UpperBound+u_s)+u_s>::val,\012           nbits = AC_MAX(l_nbits, u_nbits + (!u_s && signedness))\012         };\012    typedef ac_int<nbits, signedness> type;\012  };\012}\012\012enum ac_q_mode { AC_TRN, AC_RND, AC_TRN_ZERO, AC_RND_ZERO, AC_RND_INF, AC_RND_MIN_INF, AC_RND_CONV, AC_RND_CONV_ODD };\012enum ac_o_mode { AC_WRAP, AC_SAT, AC_SAT_ZERO, AC_SAT_SYM };\012template<int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2> class ac_fixed;\012\012//////////////////////////////////////////////////////////////////////////////\012//  Arbitrary-Length Integer: ac_int\012//////////////////////////////////////////////////////////////////////////////\012\012template<int W, bool S=true>\012class ac_int : public ac_private::iv_conv<W, S, W<=64>\012{\012  typedef ac_private::iv_conv<W, S, W <= 64> ConvBase;\012  typedef ac_private::iv<W, S>               Base;\012\012  inline bool is_neg() const { return S && Base::value < 0; }\012\012  enum ac_debug_op { \012    AC_DEBUG_ADD,\012    AC_DEBUG_SUB, \012    AC_DEBUG_MUL,\012    AC_DEBUG_DIV,\012    AC_DEBUG_REM,\012    AC_DEBUG_INCREMENT,\012    AC_DEBUG_DECREMENT\012  };\012\012  // returns false if number is denormal\012  template<int WE, bool SE>\012  bool normalize_private(ac_int<WE,SE> &exp, bool reserved_min_exp=false) {\012    int expt = exp;\012    int lshift = leading_sign();\012    bool fully_normalized = true;\012    ac_int<WE, SE> min_exp = 0;\012    min_exp.template set_val<AC_VAL_MIN>();\012    int max_shift = exp - min_exp - reserved_min_exp;\012    if(lshift > max_shift) {\012      lshift = ac_int<WE,false>(max_shift);\012      expt = min_exp + reserved_min_exp;\012      fully_normalized = false;\012    } else {\012      expt -= lshift;\012    }\012    if(Base::equal_zero()) {\012      expt = 0;\012      fully_normalized = true;\012    }\012    exp = expt;\012    Base r;\012    Base::shift_l(lshift, r);\012    Base::operator=(r);\012    return fully_normalized;\012  }\012\012public:\012  static constexpr int width = W;\012  static constexpr int i_width = W;\012  static constexpr bool sign = S;\012  static constexpr ac_q_mode q_mode = AC_TRN;\012  static constexpr ac_o_mode o_mode = AC_WRAP;\012  static constexpr int e_width = 0;\012\012  template<int W2, bool S2>\012  struct rt {\012    enum {\012      mult_w = W+W2,\012      mult_s = S||S2,\012      plus_w = AC_MAX(W+(S2&&!S),W2+(S&&!S2))+1,\012      plus_s = S||S2,\012      minus_w = AC_MAX(W+(S2&&!S),W2+(S&&!S2))+1,\012      minus_s = true,\012      div_w = W+S2,\012      div_s = S||S2,\012      mod_w = AC_MIN(W,W2+(!S2&&S)),\012      mod_s = S,\012      logic_w = AC_MAX(W+(S2&&!S),W2+(S&&!S2)),\012      logic_s = S||S2\012    };\012    typedef ac_int<mult_w, mult_s> mult;\012    typedef ac_int<plus_w, plus_s> plus;\012    typedef ac_int<minus_w, minus_s> minus;\012    typedef ac_int<logic_w, logic_s> logic;\012    typedef ac_int<div_w, div_s> div;\012    typedef ac_int<mod_w, mod_s> mod;\012    typedef ac_int<W, S> arg1;\012  };\012\012  template<typename T>\012  struct rt_T {\012    typedef typename ac_private::map<T>::t map_T;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::mult mult;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::plus plus;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::minus minus;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::minus2 minus2;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::logic logic;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::div div;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::div2 div2;\012    typedef ac_int<W, S> arg1;\012  };\012\012  struct rt_unary {\012    enum {\012      neg_w = W+1,\012      neg_s = true,\012      mag_sqr_w = 2*W-S,\012      mag_sqr_s = false,\012      mag_w = W+S,\012      mag_s = false,\012      leading_sign_w = ac::log2_ceil<W+!S>::val,\012      leading_sign_s = false\012    };\012    typedef ac_int<neg_w, neg_s> neg;\012    typedef ac_int<mag_sqr_w, mag_sqr_s> mag_sqr;\012    typedef ac_int<mag_w, mag_s> mag;\012    typedef ac_int<leading_sign_w, leading_sign_s> leading_sign;\012    template<unsigned N>\012    struct set {\012      enum { sum_w = W + ac::log2_ceil<N>::val, sum_s = S};\012      typedef ac_int<sum_w, sum_s> sum;\012    };\012  };\012\012  template<int W2, bool S2> friend class ac_int;\012  template<int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2> friend class ac_fixed;\012\012  __HLS_CONSTEXPR__ ac_int() {\012    #if !defined(__HLS_USE_CONSTEXPR__)\012      if(!warned_undef) {\012        printf(\"warning: using empty constructor for type %s\\n\", type_name().c_str());\012        warned_undef = true;\012        #ifdef DEBUG_AC_INT_ERROR\012        AC_ASSERT(0, \"Assert due to using empty constructor (DEBUG_AC_INT_ERROR)\\n\");\012        #endif\012      }\012    #endif\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ inline ac_int (const ac_int<W2,S2> &op) : ConvBase(op) {\012    Base::debug_within_range(op);\012  }\012\012  __HLS_CONSTEXPR__ inline ac_int( bool b ) : ConvBase(b) { }\012  __HLS_CONSTEXPR__ inline ac_int( char b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int(signed char b) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int(unsigned char b) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int(signed short b) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int(unsigned short b) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int(signed int b) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int( unsigned int b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int( signed long b ) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int( unsigned long b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  __HLS_CONSTEXPR__ inline ac_int( Slong b ) : ConvBase(b) {\012    Base::debug_within_range(b);\012  }\012  __HLS_CONSTEXPR__ inline ac_int( Ulong b ) : ConvBase(b) {\012    Base::debug_within_range(b);\012  }\012  constexpr ac_int(double d) : ConvBase(d) {}\012\012#if defined(__clang__)\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wuninitialized\"\012#endif\012  template<ac_special_val V>\012  __HLS_CONSTEXPR__ inline ac_int &set_val() {\012    if(V == AC_VAL_DC) {\012      ac_int r = 0;\012      Base::operator =(r);\012    }\012    else if(V == AC_VAL_0 || V == AC_VAL_MIN || V == AC_VAL_QUANTUM) {\012      Base::operator =(0);\012      if(S && V == AC_VAL_MIN) {\012        Base::value = 1;\012        Base::value <<= W - 1;\012      } else if(V == AC_VAL_QUANTUM)\012        Base::value = 1;\012    }\012    else if(AC_VAL_MAX) {\012      Base::value = 0;\012      Base::value = ~Base::value;\012      if(S){\012        ac_private::ap_uint<W> t = Base::value;\012        t >>= 1;\012        Base::value = t;\012      }\012    }\012    return *this;\012  }\012#if defined(__clang__)\012#pragma clang diagnostic pop\012#endif\012\012  // Explicit conversion functions to C built-in types -------------\012  constexpr int to_int() const { return (int) Base::value; }\012  constexpr unsigned to_uint() const { return (unsigned) Base::value; }\012  constexpr long to_long() const { return (long) Base::value; }\012  constexpr unsigned long to_ulong() const { return (unsigned long) Base::value; }\012  constexpr Slong to_int64() const { return Base::to_int64(); }\012  constexpr Ulong to_uint64() const { return Base::to_uint64(); }\012  inline double to_double() const { return Base::to_double(); }\012\012  constexpr int length() const { return W; }\012\012  inline std::string to_string(ac_base_mode base_rep, bool sign_mag = false) const {\012    return Base::to_string(base_rep);\012  }\012\012  inline static std::string type_name() {\012    const char *tf[] = {\",false>\", \",true>\"};\012    std::string r = \"ac_int<\";\012    r += ac_int<32,true>(W).to_string(AC_DEC);\012    r += tf[S];\012    return r;\012  }\012\012  // Arithmetic : Binary ----------------------------------------------------\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::mult operator *( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::mult r = 0;\012    Base::mult(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::plus operator +( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::plus r = 0;\012    Base::add(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::minus operator -( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::minus r = 0;\012    Base::sub(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::div operator /( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::div r = 0;\012    Base::div(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::mod operator %( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::mod r = 0;\012    Base::rem(op2, r);\012    return r;\012  }\012\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ void check_overflow(const ac_int<W2, S2> &op2, ac_debug_op debug_op){\012    #if !defined(__HLS_USE_CONSTEXPR__)\012    ac_int<W, S> temp = 0;\012    switch (debug_op){\012      case AC_DEBUG_ADD:\012        temp = (*this) + op2;\012        break;\012      case AC_DEBUG_SUB: \012        temp = (*this) - op2;\012        break;\012      case AC_DEBUG_MUL:\012        temp = (*this) * op2;\012        break;\012      case AC_DEBUG_DIV:\012        temp = (*this) / op2;\012        break;\012      case AC_DEBUG_REM:\012        temp = (*this) % op2;\012        break;\012      \012      default:\012        break;\012\012    }\012    #endif\012  }\012\012  __HLS_CONSTEXPR__ void check_overflow(ac_debug_op debug_op){\012    #if !defined(__HLS_USE_CONSTEXPR__)\012    ac_int<W, S> temp = 0;\012    ac_int<2, true> op2 = 1;\012    switch (debug_op){\012      case AC_DEBUG_INCREMENT :\012        temp = (*this) + op2;\012        break;\012      case AC_DEBUG_DECREMENT : \012        temp = (*this) - op2;\012        break;\012      \012      default:\012        break;\012    }\012    #endif\012  }\012  //END: X86 DEBUG\012\012  // Arithmetic assign  ------------------------------------------------------\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator *=(const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_MUL);\012    Base r = 0;\012    Base::mult(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator +=(const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_ADD);\012    Base r = 0;\012    Base::add(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator -=(const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_SUB);\012    Base r = 0;\012    Base::sub(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator /=(const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_DIV);\012    Base r = 0;\012    Base::div(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator %=(const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_REM);\012    Base r = 0;\012    Base::mod(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  // Arithmetic prefix increment, decrement ----------------------------------\012  __HLS_CONSTEXPR__ ac_int &operator ++() {\012    check_overflow(AC_DEBUG_INCREMENT);\012    Base::increment();\012    return *this;\012  }\012  __HLS_CONSTEXPR__ ac_int &operator --() {\012    check_overflow(AC_DEBUG_DECREMENT);\012    Base::decrement();\012    return *this;\012  }\012  // Arithmetic postfix increment, decrement ---------------------------------\012  __HLS_CONSTEXPR__ ac_int operator ++(int) {\012    check_overflow(AC_DEBUG_INCREMENT);\012    ac_int t = *this;\012    Base::increment();\012    return t;\012  }\012  __HLS_CONSTEXPR__ ac_int operator --(int) {\012    check_overflow(AC_DEBUG_DECREMENT);\012    ac_int t = *this;\012    Base::decrement();\012    return t;\012  }\012  // Arithmetic Unary --------------------------------------------------------\012  __HLS_CONSTEXPR__ ac_int operator +() {\012    return *this;\012  }\012  __HLS_CONSTEXPR__ typename rt_unary::neg operator -() const {\012    typename rt_unary::neg r = 0;\012    Base::neg(r);\012    return r;\012  }\012  // ! ------------------------------------------------------------------------\012  constexpr bool operator ! () const {\012    return Base::equal_zero();\012  }\012\012  // Bitwise (arithmetic) unary: complement  -----------------------------\012  __HLS_CONSTEXPR__ ac_int<W+!S, true> operator ~() const {\012    ac_int<W+!S, true> r = 0;\012    Base::bitwise_complement(r);\012    return r;\012  }\012  // Bitwise (non-arithmetic) bit_complement  -----------------------------\012  __HLS_CONSTEXPR__ ac_int<W, false> bit_complement() const {\012    ac_int<W, false> r = 0;\012    Base::bitwise_complement(r);\012    return r;\012  }\012  // Bitwise (arithmetic): and, or, xor ----------------------------------\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::logic operator & ( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::logic r = 0;\012    Base::bitwise_and(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::logic operator | ( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::logic r = 0;\012    Base::bitwise_or(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ typename rt<W2,S2>::logic operator ^ ( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::logic r = 0;\012    Base::bitwise_xor(op2, r);\012    return r;\012  }\012  // Bitwise assign (not arithmetic): and, or, xor ----------------------------\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator &= ( const ac_int<W2,S2> &op2 ) {\012    Base r = 0;\012    Base::bitwise_and(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator |= ( const ac_int<W2,S2> &op2 ) {\012    Base r = 0;\012    Base::bitwise_or(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ ac_int &operator ^= ( const ac_int<W2,S2> &op2 ) {\012    Base r = 0;\012    Base::bitwise_xor(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  // Shift (result constrained by left operand) -------------------------------\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int operator << ( const ac_int<W2,true> &op2 ) const {\012    ac_int r = 0;\012    Base::shift_l2(op2.to_int(), r);\012    return r;\012  }\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int operator << ( const ac_int<W2,false> &op2 ) const {\012    ac_int r = 0;\012    Base::shift_l(op2.to_uint(), r);\012    return r;\012  }\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int operator >> ( const ac_int<W2,true> &op2 ) const {\012    ac_int r = 0;\012    Base::shift_r2(op2.to_int(), r);\012    return r;\012  }\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int operator >> ( const ac_int<W2,false> &op2 ) const {\012    ac_int r = 0;\012    Base::shift_r(op2.to_uint(), r);\012    return r;\012  }\012  // Shift assign ------------------------------------------------------------\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int &operator <<= ( const ac_int<W2,true> &op2 ) {\012    Base r = 0;\012    Base::shift_l2(op2.to_int(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int &operator <<= ( const ac_int<W2,false> &op2 ) {\012    Base r = 0;\012    Base::shift_l(op2.to_uint(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int &operator >>= ( const ac_int<W2,true> &op2 ) {\012    Base r = 0;\012    Base::shift_r2(op2.to_int(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2>\012  __HLS_CONSTEXPR__ ac_int &operator >>= ( const ac_int<W2,false> &op2 ) {\012    Base r = 0;\012    Base::shift_r(op2.to_uint(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  // Relational ---------------------------------------------------------------\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ bool operator == ( const ac_int<W2,S2> &op2) const {\012    return Base::equal(op2);\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ bool operator != ( const ac_int<W2,S2> &op2) const {\012    return !Base::equal(op2);\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ bool operator < ( const ac_int<W2,S2> &op2) const {\012    return Base::less_than(op2);\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ bool operator >= ( const ac_int<W2,S2> &op2) const {\012    return !Base::less_than(op2);\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ bool operator > ( const ac_int<W2,S2> &op2) const {\012    return Base::greater_than(op2);\012  }\012  template<int W2, bool S2>\012  __HLS_CONSTEXPR__ bool operator <= ( const ac_int<W2,S2> &op2) const {\012    return !Base::greater_than(op2);\012  }\012\012  // Bit and Slice Select -----------------------------------------------------\012  template<int WS, int WX, bool SX>\012  inline ac_int<WS,S> slc(const ac_int<WX,SX> &index) const {\012    ac_int<W, S> op = *this;\012    ac_int<WS, S> r = 0;\012    AC_ASSERT(index >= 0, \"Attempting to read slc with negative indeces\");\012    ac_int<WX-SX, false> uindex = index;\012    Base::shift_r(uindex.to_uint(), op);\012    r = op;\012    return r;\012  }\012\012  template<int WS>\012  inline ac_int<WS,S> slc(signed index) const {\012    ac_int<W, S> op = *this;\012    ac_int<WS,S> r = 0;\012    AC_ASSERT(index >= 0, \"Attempting to read slc with negative indeces\");\012    unsigned uindex = index & ((unsigned)~0 >> 1);\012    Base::shift_r(uindex, op);\012    r = op;\012    return r;\012  }\012  template<int WS>\012  inline ac_int<WS,S> slc(unsigned uindex) const {\012    ac_int<W,S> op = *this;\012    Base::shift_r(uindex, op);\012    ac_int<WS,S> r = op;\012    return r;\012  }\012\012  template<int W2, bool S2, int WX, bool SX>\012  inline ac_int &set_slc(const ac_int<WX,SX> lsb, const ac_int<W2,S2> &slc) {\012    AC_ASSERT(lsb.to_int() + W2 <= W && lsb.to_int() >= 0, \"Out of bounds set_slc\");\012    if (lsb.to_int() + W2 <= W && lsb.to_int() >= 0) {\012        ac_int<WX-SX, false> ulsb = lsb;\012        Base::set_slc(ulsb.to_uint(), W2, (ac_int<W2,false>) slc);\012    } else {\012        Base r = 0;\012        Base::operator=(r);\012    }\012    return *this;\012  }\012  template<int W2, bool S2>\012  inline ac_int &set_slc(signed lsb, const ac_int<W2,S2> &slc) {\012    AC_ASSERT(lsb + W2 <= W && lsb >= 0, \"Out of bounds set_slc\");\012    if (lsb + W2 <= W && lsb >= 0) {\012        unsigned ulsb = lsb & ((unsigned)~0 >> 1);\012        Base::set_slc(ulsb, W2, (ac_int<W2,false>) slc);\012    } else {\012        Base r = 0;\012        Base::operator=(r);\012    }\012    return *this;\012  }\012  template<int W2, bool S2>\012  inline ac_int &set_slc(unsigned ulsb, const ac_int<W2,S2> &slc) {\012    AC_ASSERT(ulsb + W2 <= W, \"Out of bounds set_slc\");\012    if (ulsb + W2 <= W) {\012        Base::set_slc(ulsb, W2, (ac_int<W2,false>) slc);\012    } else {\012        Base r = 0;\012        Base::operator=(r);\012    }\012    return *this;\012  }\012\012  class ac_bitref {\012    ac_int &d_bv;\012    unsigned d_index;\012  public:\012    ac_bitref( ac_int *bv, unsigned index=0 ) : d_bv(*bv), d_index(index) {\012    }\012    operator bool () const {\012      return (d_index < W) ? (bool)(d_bv.value>>(d_index) & 1) : 0;\012    }\012\012    template<int W2, bool S2>\012    operator ac_int<W2,S2> () const { return operator bool (); }\012\012    inline ac_bitref operator = ( int val ) {\012      // lsb of int (val&1) is written to bit\012      if(d_index < W) {\012        ac_private::ap_int<W+1> temp1 = d_bv.value;\012        ac_private::ap_int<W+1> temp2 = val;\012        temp2 <<= d_index;\012        temp1 ^= temp2;\012        temp2 = 1;\012        temp2 <<= d_index;\012        temp1 &= temp2;\012        d_bv.value ^= temp1;\012      }\012      return *this;\012    }\012    template<int W2, bool S2>\012    inline ac_bitref operator = ( const ac_int<W2,S2> &val ) {\012      return operator =(val.to_int());\012    }\012    inline ac_bitref operator = ( const ac_bitref &val ) {\012      return operator =((int) (bool) val);\012    }\012  };\012\012  ac_bitref operator [] ( unsigned int uindex) {\012    AC_ASSERT(uindex < W, \"Attempting to read bit beyond MSB\");\012    ac_bitref bvh( this, uindex );\012    return bvh;\012  }\012  ac_bitref operator [] ( int index) {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    unsigned uindex = index & ((unsigned)~0 >> 1);\012    ac_bitref bvh( this, uindex );\012    return bvh;\012  }\012  template<int W2, bool S2>\012  ac_bitref operator [] ( const ac_int<W2,S2> &index) {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    ac_int<W2-S2,false> uindex = index;\012    ac_bitref bvh( this, uindex.to_uint() );\012    return bvh;\012  }\012  bool operator [] ( unsigned int uindex) const {\012    AC_ASSERT(uindex < W, \"Attempting to read bit beyond MSB\");\012    return (uindex < W) ? (Base::v[uindex>>5]>>(uindex&31) & 1) : 0;\012  }\012  bool operator [] ( int index) const {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    unsigned uindex = index & ((unsigned)~0 >> 1);\012    return (uindex < W) ? (Base::v[uindex>>5]>>(uindex&31) & 1) : 0;\012  }\012  template<int W2, bool S2>\012  bool operator [] ( const ac_int<W2,S2> &index) const {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    ac_int<W2-S2,false> uindex = index;\012    return (uindex < W) ? (Base::v[uindex>>5]>>(uindex.to_uint()&31) & 1) : 0;\012  }\012  typename rt_unary::leading_sign leading_sign() const {\012    unsigned ls = 0;\012    return ls;\012  }\012  typename rt_unary::leading_sign leading_sign(bool &all_sign) const {\012    unsigned ls = 0;\012    return ls;\012  }\012  // returns false if number is denormal\012  template<int WE, bool SE>\012  bool normalize(ac_int<WE,SE> &exp) {\012    return false;\012  }\012  // returns false if number is denormal, minimum exponent is reserved (usually for encoding special values/errors)\012  template<int WE, bool SE>\012  bool normalize_RME(ac_int<WE,SE> &exp) {\012    return false;\012  }\012  bool and_reduce() const {\012    return false;\012  }\012  bool or_reduce() const {\012    return !Base::equal_zero();\012  }\012  bool xor_reduce() const {\012    return false;\012  }\012  ac_int reverse() const {\012    ac_int r = 0;\012    Base::reverse(r);\012    return r;\012  }\012\012  inline void bit_fill_hex(const char *str) {\012    // Zero Pads if str is too short, throws ms bits away if str is too long\012    // Asserts if anything other than 0-9a-fA-F is encountered\012    ac_int<W,S> res = 0;\012    int i = 0;\012    while(str[i]) {\012      char c = str[i];\012      ac_int<4, false> h = 0;\012      if(c >= '0' && c <= '9')\012        h = c - '0';\012      else if(c >= 'A' && c <= 'F')\012        h = c - 'A' + 10;\012      else if(c >= 'a' && c <= 'f')\012        h = c - 'a' + 10;\012      else {\012        AC_ASSERT(!c, \"Invalid hex digit\");\012        break;\012      }\012      ac_int<4, false> s = 4;\012      res =  res << s;\012      res |= h;\012      i++;\012    }\012    *this = res;\012  }\012\012  template<int Na>\012  inline void bit_fill(const int (&ivec)[Na], bool bigendian=true) {\012    // bit_fill from integer vector\012    //   if W > N*32, missing most significant bits are zeroed\012    //   if W < N*32, additional bits in ivec are ignored (no overflow checking)\012    // Example:\012    //   ac_int<80,false> x;    int vec[] = { 0xffffa987, 0x6543210f, 0xedcba987 };\012    //   x.bit_fill(vec);   // vec[0] fill bits 79-64\012    const int M = AC_MIN((W + 31)/32,Na);\012    ac_int<M*32, false> res = 0;\012    // Do not unroll this loop, the HLS flow\012    // auto unrolls for us.\012    for(int i=0; i < M; i++){\012      res.set_slc(i*32, ac_int<32, false>(ivec[bigendian ? M-1-i : i]));\012    }\012    *this = res;\012  }\012};\012\012namespace ac {\012  template<typename T, typename T2>\012  struct rt_2T {\012    typedef typename ac_private::map<T>::t map_T;\012    typedef typename ac_private::map<T2>::t map_T2;\012    typedef typename map_T::template rt_T< map_T2 >::mult mult;\012    typedef typename map_T::template rt_T< map_T2 >::plus plus;\012    typedef typename map_T::template rt_T< map_T2 >::minus minus;\012    typedef typename map_T::template rt_T< map_T2 >::minus2 minus2;\012    typedef typename map_T::template rt_T< map_T2 >::logic logic;\012    typedef typename map_T::template rt_T< map_T2 >::div div;\012    typedef typename map_T::template rt_T< map_T2 >::div2 div2;\012  };\012}\012\012namespace ac {\012  template<typename T>\012  struct ac_int_represent {\012    enum { t_w = ac_private::c_type_params<T>::W, t_s = ac_private::c_type_params<T>::S };\012    typedef ac_int<t_w,t_s> type;\012  };\012  template<> struct ac_int_represent<float> {};\012  template<> struct ac_int_represent<double> {};\012  template<int W, bool S>\012  struct ac_int_represent< ac_int<W,S> > {\012    typedef ac_int<W,S> type;\012  };\012}\012\012namespace ac_private {\012  template<int W2, bool S2>\012  struct rt_ac_int_T< ac_int<W2,S2> > {\012    typedef ac_int<W2,S2> i2_t;\012    template<int W, bool S>\012    struct op1 {\012      typedef ac_int<W,S> i_t;\012      typedef typename i_t::template rt<W2,S2>::mult mult;\012      typedef typename i_t::template rt<W2,S2>::plus plus;\012      typedef typename i_t::template rt<W2,S2>::minus minus;\012      typedef typename i2_t::template rt<W,S>::minus minus2;\012      typedef typename i_t::template rt<W2,S2>::logic logic;\012      typedef typename i_t::template rt<W2,S2>::div div;\012      typedef typename i2_t::template rt<W,S>::div div2;\012      typedef typename i_t::template rt<W2,S2>::mod mod;\012      typedef typename i2_t::template rt<W,S>::mod mod2;\012    };\012  };\012\012  template<typename T>\012  struct rt_ac_int_T< c_type<T> > {\012    typedef typename ac::ac_int_represent<T>::type i2_t;\012    enum { W2 = i2_t::width, S2 = i2_t::sign };\012    template<int W, bool S>\012    struct op1 {\012      typedef ac_int<W,S> i_t;\012      typedef typename i_t::template rt<W2,S2>::mult mult;\012      typedef typename i_t::template rt<W2,S2>::plus plus;\012      typedef typename i_t::template rt<W2,S2>::minus minus;\012      typedef typename i2_t::template rt<W,S>::minus minus2;\012      typedef typename i_t::template rt<W2,S2>::logic logic;\012      typedef typename i_t::template rt<W2,S2>::div div;\012      typedef typename i2_t::template rt<W,S>::div div2;\012      typedef typename i_t::template rt<W2,S2>::mod mod;\012      typedef typename i2_t::template rt<W,S>::mod mod2;\012    };\012  };\012}\012\012// Stream --------------------------------------------------------------------\012#if defined (__linux__)\012template<int W, bool S>\012inline std::ostream& operator << (std::ostream &os, const ac_int<W,S> &x) {\012#ifdef HLS_X86\012  os << x.to_string(AC_DEC);\012#endif\012  return os;\012}\012#endif // linux\012\012// Macros for Binary Operators with Integers --------------------------------------------\012\012#define BIN_OP_WITH_INT(BIN_OP, C_TYPE, WI, SI, RTYPE)  \\\012  template<int W, bool S> \\\012  __HLS_CONSTEXPR__ inline typename ac_int<WI,SI>::template rt<W,S>::RTYPE operator BIN_OP ( C_TYPE i_op, const ac_int<W,S> &op) {  \\\012    return ac_int<WI,SI>(i_op).operator BIN_OP (op);  \\\012  } \\\012  template<int W, bool S>   \\\012  __HLS_CONSTEXPR__ inline typename ac_int<W,S>::template rt<WI,SI>::RTYPE operator BIN_OP ( const ac_int<W,S> &op, C_TYPE i_op) {  \\\012    return op.operator BIN_OP (ac_int<WI,SI>(i_op));  \\\012  }\012\012#define REL_OP_WITH_INT(REL_OP, C_TYPE, W2, S2)  \\\012  template<int W, bool S>   \\\012  __HLS_CONSTEXPR__ inline bool operator REL_OP ( const ac_int<W,S> &op, C_TYPE op2) {  \\\012    return op.operator REL_OP (ac_int<W2,S2>(op2));  \\\012  }  \\\012  template<int W, bool S> \\\012  __HLS_CONSTEXPR__ inline bool operator REL_OP ( C_TYPE op2, const ac_int<W,S> &op) {  \\\012    return ac_int<W2,S2>(op2).operator REL_OP (op);  \\\012  }\012\012#define ASSIGN_OP_WITH_INT(ASSIGN_OP, C_TYPE, W2, S2)  \\\012  template<int W, bool S>   \\\012  __HLS_CONSTEXPR__ inline ac_int<W,S> &operator ASSIGN_OP ( ac_int<W,S> &op, C_TYPE op2) {  \\\012    return op.operator ASSIGN_OP (ac_int<W2,S2>(op2));  \\\012  }\012\012#define OPS_WITH_INT(C_TYPE, WI, SI) \\\012  BIN_OP_WITH_INT(*, C_TYPE, WI, SI, mult) \\\012  BIN_OP_WITH_INT(+, C_TYPE, WI, SI, plus) \\\012  BIN_OP_WITH_INT(-, C_TYPE, WI, SI, minus) \\\012  BIN_OP_WITH_INT(/, C_TYPE, WI, SI, div) \\\012  BIN_OP_WITH_INT(%, C_TYPE, WI, SI, mod) \\\012  BIN_OP_WITH_INT(>>, C_TYPE, WI, SI, arg1) \\\012  BIN_OP_WITH_INT(<<, C_TYPE, WI, SI, arg1) \\\012  BIN_OP_WITH_INT(&, C_TYPE, WI, SI, logic) \\\012  BIN_OP_WITH_INT(|, C_TYPE, WI, SI, logic) \\\012  BIN_OP_WITH_INT(^, C_TYPE, WI, SI, logic) \\\012  \\\012  REL_OP_WITH_INT(==, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(!=, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(>, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(>=, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(<, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(<=, C_TYPE, WI, SI) \\\012  \\\012  ASSIGN_OP_WITH_INT(+=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(-=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(*=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(/=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(%=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(>>=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(<<=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(&=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(|=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(^=, C_TYPE, WI, SI)\012\012// ------------------------------------- End of Macros for Binary Operators with Integers\012\012namespace ac {\012  namespace ops_with_other_types {\012    //  Mixed Operators with Integers  -----------------------------------------------\012    OPS_WITH_INT(bool, 1, false)\012    OPS_WITH_INT(char, 8, true)\012    OPS_WITH_INT(signed char, 8, true)\012    OPS_WITH_INT(unsigned char, 8, false)\012    OPS_WITH_INT(short, 16, true)\012    OPS_WITH_INT(unsigned short, 16, false)\012    OPS_WITH_INT(int, 32, true)\012    OPS_WITH_INT(unsigned int, 32, false)\012    OPS_WITH_INT(long, ac_private::long_w, true)\012    OPS_WITH_INT(unsigned long, ac_private::long_w, false)\012    OPS_WITH_INT(Slong, 64, true)\012    OPS_WITH_INT(Ulong, 64, false)\012    // -----------------------------------------  End of Mixed Operators with Integers\012  }  // ops_with_other_types namespace\012\012  // Functions to fill bits\012\012  template<typename T>\012  inline T bit_fill_hex(const char *str) {\012    T res;\012    res.bit_fill_hex(str);\012    return res;\012  }\012\012  // returns bit_fill for type\012  //   example:\012  //   ac_int<80,false> x = ac::bit_fill< ac_int<80,false> > ((int [3]) {0xffffa987, 0x6543210f, 0xedcba987 });\012  template<typename T, int N>\012  inline T bit_fill(const int (&ivec)[N], bool bigendian=true) {\012    T res;\012    res.bit_fill(ivec, bigendian);\012    return res;\012  }\012\012}  // ac namespace\012\012//  Mixed Operators with Pointers  -----------------------------------------------\012\012// Addition of ac_int and  pointer\012template<typename T, int W, bool S>\012T *operator +(T *ptr, const ac_int<W,S> &op2) {\012  return ptr + op2.to_int64();\012}\012template<typename T, int W, bool S>\012T *operator +(const ac_int<W,S> &op2, T *ptr) {\012  return ptr + op2.to_int64();\012}\012// Subtraction of ac_int from pointer\012template<typename T, int W, bool S>\012T *operator -(T *ptr, const ac_int<W,S> &op2) {\012  return ptr - op2.to_int64();\012}\012// -----------------------------------------  End of Mixed Operators with Pointers\012\012using namespace ac::ops_with_other_types;\012\012namespace ac_intN {\012  ///////////////////////////////////////////////////////////////////////////////\012  //  Predefined for ease of use\012  ///////////////////////////////////////////////////////////////////////////////\012  typedef ac_int<1,          true>   int1;\012  typedef ac_int<1,          false>  uint1;\012  typedef ac_int<2,          true>   int2;\012  typedef ac_int<2,          false>  uint2;\012  typedef ac_int<3,          true>   int3;\012  typedef ac_int<3,          false>  uint3;\012  typedef ac_int<4,          true>   int4;\012  typedef ac_int<4,          false>  uint4;\012  typedef ac_int<5,          true>   int5;\012  typedef ac_int<5,          false>  uint5;\012  typedef ac_int<6,          true>   int6;\012  typedef ac_int<6,          false>  uint6;\012  typedef ac_int<7,          true>   int7;\012  typedef ac_int<7,          false>  uint7;\012  typedef ac_int<8,          true>   int8;\012  typedef ac_int<8,          false>  uint8;\012  typedef ac_int<9,          true>   int9;\012  typedef ac_int<9,          false>  uint9;\012  typedef ac_int<10,         true>   int10;\012  typedef ac_int<10,         false>  uint10;\012  typedef ac_int<11,         true>   int11;\012  typedef ac_int<11,         false>  uint11;\012  typedef ac_int<12,         true>   int12;\012  typedef ac_int<12,         false>  uint12;\012  typedef ac_int<13,         true>   int13;\012  typedef ac_int<13,         false>  uint13;\012  typedef ac_int<14,         true>   int14;\012  typedef ac_int<14,         false>  uint14;\012  typedef ac_int<15,         true>   int15;\012  typedef ac_int<15,         false>  uint15;\012  typedef ac_int<16,         true>   int16;\012  typedef ac_int<16,         false>  uint16;\012  typedef ac_int<17,         true>   int17;\012  typedef ac_int<17,         false>  uint17;\012  typedef ac_int<18,         true>   int18;\012  typedef ac_int<18,         false>  uint18;\012  typedef ac_int<19,         true>   int19;\012  typedef ac_int<19,         false>  uint19;\012  typedef ac_int<20,         true>   int20;\012  typedef ac_int<20,         false>  uint20;\012  typedef ac_int<21,         true>   int21;\012  typedef ac_int<21,         false>  uint21;\012  typedef ac_int<22,         true>   int22;\012  typedef ac_int<22,         false>  uint22;\012  typedef ac_int<23,         true>   int23;\012  typedef ac_int<23,         false>  uint23;\012  typedef ac_int<24,         true>   int24;\012  typedef ac_int<24,         false>  uint24;\012  typedef ac_int<25,         true>   int25;\012  typedef ac_int<25,         false>  uint25;\012  typedef ac_int<26,         true>   int26;\012  typedef ac_int<26,         false>  uint26;\012  typedef ac_int<27,         true>   int27;\012  typedef ac_int<27,         false>  uint27;\012  typedef ac_int<28,         true>   int28;\012  typedef ac_int<28,         false>  uint28;\012  typedef ac_int<29,         true>   int29;\012  typedef ac_int<29,         false>  uint29;\012  typedef ac_int<30,         true>   int30;\012  typedef ac_int<30,         false>  uint30;\012  typedef ac_int<31,         true>   int31;\012  typedef ac_int<31,         false>  uint31;\012  typedef ac_int<32,         true>   int32;\012  typedef ac_int<32,         false>  uint32;\012  typedef ac_int<33,         true>   int33;\012  typedef ac_int<33,         false>  uint33;\012  typedef ac_int<34,         true>   int34;\012  typedef ac_int<34,         false>  uint34;\012  typedef ac_int<35,         true>   int35;\012  typedef ac_int<35,         false>  uint35;\012  typedef ac_int<36,         true>   int36;\012  typedef ac_int<36,         false>  uint36;\012  typedef ac_int<37,         true>   int37;\012  typedef ac_int<37,         false>  uint37;\012  typedef ac_int<38,         true>   int38;\012  typedef ac_int<38,         false>  uint38;\012  typedef ac_int<39,         true>   int39;\012  typedef ac_int<39,         false>  uint39;\012  typedef ac_int<40,         true>   int40;\012  typedef ac_int<40,         false>  uint40;\012  typedef ac_int<41,         true>   int41;\012  typedef ac_int<41,         false>  uint41;\012  typedef ac_int<42,         true>   int42;\012  typedef ac_int<42,         false>  uint42;\012  typedef ac_int<43,         true>   int43;\012  typedef ac_int<43,         false>  uint43;\012  typedef ac_int<44,         true>   int44;\012  typedef ac_int<44,         false>  uint44;\012  typedef ac_int<45,         true>   int45;\012  typedef ac_int<45,         false>  uint45;\012  typedef ac_int<46,         true>   int46;\012  typedef ac_int<46,         false>  uint46;\012  typedef ac_int<47,         true>   int47;\012  typedef ac_int<47,         false>  uint47;\012  typedef ac_int<48,         true>   int48;\012  typedef ac_int<48,         false>  uint48;\012  typedef ac_int<49,         true>   int49;\012  typedef ac_int<49,         false>  uint49;\012  typedef ac_int<50,         true>   int50;\012  typedef ac_int<50,         false>  uint50;\012  typedef ac_int<51,         true>   int51;\012  typedef ac_int<51,         false>  uint51;\012  typedef ac_int<52,         true>   int52;\012  typedef ac_int<52,         false>  uint52;\012  typedef ac_int<53,         true>   int53;\012  typedef ac_int<53,         false>  uint53;\012  typedef ac_int<54,         true>   int54;\012  typedef ac_int<54,         false>  uint54;\012  typedef ac_int<55,         true>   int55;\012  typedef ac_int<55,         false>  uint55;\012  typedef ac_int<56,         true>   int56;\012  typedef ac_int<56,         false>  uint56;\012  typedef ac_int<57,         true>   int57;\012  typedef ac_int<57,         false>  uint57;\012  typedef ac_int<58,         true>   int58;\012  typedef ac_int<58,         false>  uint58;\012  typedef ac_int<59,         true>   int59;\012  typedef ac_int<59,         false>  uint59;\012  typedef ac_int<60,         true>   int60;\012  typedef ac_int<60,         false>  uint60;\012  typedef ac_int<61,         true>   int61;\012  typedef ac_int<61,         false>  uint61;\012  typedef ac_int<62,         true>   int62;\012  typedef ac_int<62,         false>  uint62;\012  typedef ac_int<63,         true>   int63;\012  typedef ac_int<63,         false>  uint63;\012}  // namespace ac_intN\012\012#ifndef AC_NOT_USING_INTN\012using namespace ac_intN;\012#endif\012\012///////////////////////////////////////////////////////////////////////////////\012\012// Global templatized functions for easy initialization to special values\012template<ac_special_val V, int W, bool S>\012inline ac_int<W,S> value(ac_int<W,S>) {\012  ac_int<W,S> r = 0;\012  return r.template set_val<V>();\012}\012// forward declaration, otherwise GCC errors when calling init_array\012template<ac_special_val V, int W, int I, bool S, ac_q_mode Q, ac_o_mode O>\012inline ac_fixed<W,I,S,Q,O> value(ac_fixed<W,I,S,Q,O>);\012\012#define SPECIAL_VAL_FOR_INTS_DC(C_TYPE, WI, SI) \\\012template<> inline C_TYPE value<AC_VAL_DC>(C_TYPE) { C_TYPE x=0; return x; }\012\012// -- C int types -----------------------------------------------------------------\012#define SPECIAL_VAL_FOR_INTS(C_TYPE, WI, SI) \\\012template<ac_special_val val> inline C_TYPE value(C_TYPE); \\\012template<> inline C_TYPE value<AC_VAL_0>(C_TYPE) { return (C_TYPE)0; } \\\012SPECIAL_VAL_FOR_INTS_DC(C_TYPE, WI, SI) \\\012template<> inline C_TYPE value<AC_VAL_QUANTUM>(C_TYPE) { return (C_TYPE)1; } \\\012template<> inline C_TYPE value<AC_VAL_MAX>(C_TYPE) { return (C_TYPE)(SI ? ~((C_TYPE) 1 << (WI-1)) : (C_TYPE) -1); } \\\012template<> inline C_TYPE value<AC_VAL_MIN>(C_TYPE) { return (C_TYPE)(SI ? (C_TYPE) 1 << (WI-1) : 0); }\012\012SPECIAL_VAL_FOR_INTS(bool, 1, false)\012SPECIAL_VAL_FOR_INTS(char, 8, true)\012SPECIAL_VAL_FOR_INTS(signed char, 8, true)\012SPECIAL_VAL_FOR_INTS(unsigned char, 8, false)\012SPECIAL_VAL_FOR_INTS(short, 16, true)\012SPECIAL_VAL_FOR_INTS(unsigned short, 16, false)\012SPECIAL_VAL_FOR_INTS(int, 32, true)\012SPECIAL_VAL_FOR_INTS(unsigned int, 32, false)\012SPECIAL_VAL_FOR_INTS(long, ac_private::long_w, true)\012SPECIAL_VAL_FOR_INTS(unsigned long, ac_private::long_w, false)\012SPECIAL_VAL_FOR_INTS(Slong, 64, true)\012SPECIAL_VAL_FOR_INTS(Ulong, 64, false)\012\012#define INIT_ARRAY_SPECIAL_VAL_FOR_INTS(C_TYPE) \\\012  template<ac_special_val V> \\\012  inline bool init_array(C_TYPE *a, int n) { \\\012    C_TYPE t = value<V>(*a); \\\012    for(int i=0; i < n; i++) \\\012      a[i] = t; \\\012    return true; \\\012  }\012\012namespace ac {\012// PUBLIC FUNCTIONS\012// function to initialize (or uninitialize) arrays\012  template<ac_special_val V, int W, bool S>\012  inline bool init_array(ac_int<W,S> *a, int n) {\012    ac_int<W,S> t = value<V>(*a);\012    for(int i=0; i < n; i++)\012      a[i] = t;\012    return true;\012  }\012\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(bool)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(char)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed char)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned char)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed short)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned short)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed int)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned int)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed long)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned long)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed long long)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned long long)\012}\012\012#ifdef __AC_NAMESPACE\012}\012#endif\012#endif // __ALTR_AC_INT_H\012"}, {"path":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifdef __INTELFPGA_COMPILER__\012   // Compiling for FPGA or x86 using FPGA compiler\012#  undef component\012#  define component __attribute__((ihc_component)) __attribute__((noinline))\012#else\012#  ifndef component\012#    define component\012#  endif\012#  ifndef HLS_X86\012#    define HLS_X86\012#  endif\012#endif\012#include <type_traits>\012#include \"HLS/hls_internal.h\"\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_memory_impl(__x)                          __attribute__((__memory_impl__(__x)))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012\012// Memory attribute macros\012#define hls_simple_dual_port_memory hls_memory hls_singlepump hls_numports_readonly_writeonly(1,1)\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012  template<int _N> struct dwidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct awidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct latency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct readwrite_mode {\012    // Should be enum readwrite_t but we don't know how to make GetValue generic\012    static constexpr enum readwrite_t value = (readwrite_t) _N;\012    static constexpr enum readwrite_t defaultValue = readwrite;\012  };\012\012  template<int _N> struct maxburst {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct align {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = -1;\012  };\012\012  template<int _N> struct aspace {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct waitrequest {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template <template <int> class _Type, class _T>\012  struct MatchType : std::is_same<_Type<_T::value>,_T> {};\012\012  template <template <int> class _Type, class ... _T>\012  struct GetValue {\012    // any value is ok here, so '0' is fine for an arbitrary instantiation\012    enum { value = _Type<0>::defaultValue };\012    // only when _T is empty\012  };\012\012  template <template <int> class _Type, class _T1, class ... _T>\012  struct GetValue<_Type, _T1, _T...> {\012    enum { value = std::conditional<MatchType<_Type, _T1>::value, _T1, GetValue<_Type, _T...>>::type::value };\012  };\012\012template <typename _DT, class ... _Params>\012class mm_master final\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template <typename _T>\012  explicit mm_master(_T *data, std::size_t size = 0, bool use_socket = false)\012      : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                              _readwrite_mode, true, _maxburst, _align,\012                              _waitrequest, data, size, sizeof(_DT),\012                              use_socket) {\012    mSize = size;\012    mUse_socket = use_socket;\012    if (size > 0 && size % sizeof(_DT) != 0) {\012      __ihc_hls_runtime_error_x86(\012          \"The buffer size must be a multiple of the type size\");\012    }\012  }\012#else\012  template<typename _T> explicit mm_master(_T *data, std::size_t size=0, bool use_socket=false);\012#endif\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // but illegal in a component\012  mm_master(const mm_master &other); \012\012  mm_master& operator=(const mm_master& other);\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master();\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator _T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  _DT &operator[](int index);\012  _DT &operator*();\012  _DT *operator->();\012  template<typename _T> operator _T();\012  _DT *operator+(int index);\012  template<typename _T> _DT *operator&(_T value);\012  template<typename _T> _DT *operator|(_T value);\012  template<typename _T> _DT *operator^(_T value);\012  // This function is only supported in the testbench:\012  mm_master<_DT, _Params...>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012private:\012  std::vector<internal::memory_base* > new_masters;\012#else //Fpga\012\012\012#endif\012private:\012  static constexpr int _dwidth   = GetValue<ihc::dwidth, _Params...>::value;\012  static constexpr int _awidth   = GetValue<ihc::awidth, _Params...>::value;\012  static constexpr int _aspace   = GetValue<ihc::aspace, _Params...>::value;\012  static constexpr int _latency  = GetValue<ihc::latency, _Params...>::value;\012  static constexpr int _maxburst = GetValue<ihc::maxburst, _Params...>::value;\012  static constexpr int _align    = (GetValue<ihc::align, _Params...>::value == -1) ? alignof(_DT) : GetValue<ihc::align, _Params...>::value;\012  static constexpr int _readwrite_mode = GetValue<ihc::readwrite_mode, _Params...>::value;\012  static constexpr bool _waitrequest = GetValue<ihc::waitrequest, _Params...>::value;\012\012\012  _DT* mPtr;\012  int mSize;\012  bool mUse_socket;\012};\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012  template<int _N> struct buffer {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012  \012  template<int _N> struct readyLatency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct bitsPerSymbol {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct usesPackets {\012    static constexpr bool value = _N;\012    static constexpr bool defaultValue = false;\012  };\012\012  template<int _N> struct usesValid {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesReady {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesEmpty {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template<int _N> struct firstSymbolInHighOrderBits {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012template <typename _T, class ... _Params>\012class stream_in final : public internal::stream<_T, _Params...> {\012public:\012  stream_in();\012  _T read();\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop);\012  _T read(bool& sop, bool& eop, int& empty);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits =  GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012template <typename _T, class ... _Params>\012class stream_out final : public internal::stream<_T, _Params...> {\012\012public:\012  stream_out();\012  _T read();\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop);\012  _T read(bool& sop, bool& eop, int& empty);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits = GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {};\012\012#else\012extern \"C\" void mem_fence(int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // necessary to ensurebut illegal in a component\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...>::mm_master(const mm_master &other)\012    : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                            static_cast<readwrite_t>(_readwrite_mode), true,\012                            _maxburst, _align, _waitrequest, other.get_base(),\012                            other.get_size(), sizeof(_DT),\012                            other.uses_socket()) {\012  mPtr = other.mPtr;\012  mSize = other.mSize;\012  mUse_socket = other.mUse_socket;\012  mem = other.mem;\012}\012\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>& mm_master<_DT, _Params...>::operator=(const mm_master& other) {\012    mPtr = other.mPtr;\012    mSize = other.mSize;\012    mUse_socket = other.m_Use_socket;\012    mem = other.mem;\012  }\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>::~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params... >::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((_DT*)mem)[index];\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator*() {\012  return ((_DT*)mem)[0];\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator->() {\012  return (_DT*)mem;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)mem);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((_DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename _DT, class ... _Params>\012mm_master<_DT, _Params...>& mm_master<_DT,_Params...>::getInterfaceAtIndex(int index) {\012  assert(mSize==0 || index*data_size<mSize);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<_DT, _Params...> *temp = new mm_master(&(((_DT*)mem)[index]), mSize - index * sizeof(_DT), mUse_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012stream_in<_T,_Params...>::stream_in() {}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  success = !internal::stream<_T,_Params...>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return _T();\012  }\012}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read() {\012    _T elem = internal::stream<_T,_Params...>::read();\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<_T,_Params...>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return _T();\012  }\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  success = !internal::stream<_T,_Params...>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop, empty);\012  } else {\012    return _T();\012  }\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  stream_out<_T,_Params...>::stream_out() {\012}\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  success = !internal::stream<_T,_Params...>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return _T();\012  }\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read() {\012    _T elem = internal::stream<_T,_Params...>::read();\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<_T,_Params...>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return _T();\012  }\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  success = !internal::stream<_T,_Params...>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop, empty);\012  } else {\012    return _T();\012  }\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_ready, ready_delta);\012}\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator[](int index) {\012  return *__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, index);\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT,_Params...>::operator*(){\012  return *__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT,_Params...>::operator->(){\012  return __builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  return __builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0) + index;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0));\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) ^ (unsigned long long)value);\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  static_assert((_usesPackets==_usesEmpty)||(_usesPackets&&!_usesEmpty), \"Empty baseds reads request a stream with the parametrizations: usesPackets<true>, usesEmty<true>\");     \012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read() {\012  static_assert((_usesPackets==_usesEmpty)||(_usesPackets&&!_usesEmpty), \"Empty baseds reads request a stream with the parametrizations: usesPackets<true>, usesEmty<true>\");     \012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0 );\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer,  _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");  \012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0 );\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this,  _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, empty );\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read() {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp );\012}\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012  static_assert((_usesPackets==_usesEmpty)||(_usesPackets&&!_usesEmpty), \"Empty baseds reads request a stream with the parametrizations: usesPackets<true>, usesEmty<true>\"); \012 __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  static_assert((_usesPackets==_usesEmpty)||(_usesPackets&&!_usesEmpty), \"Empty baseds reads request a stream with the parametrizations: usesPackets<true>, usesEmty<true>\");  \012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop) {\012  int emp;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &empty );\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012#endif\012} // namespace ihc\012\012#endif\012\012"}, {"path":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#include <stdio.h>\012#include <stdlib.h>\012#endif\012\012#if defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012\012#ifdef HLS_X86\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012#endif\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012// ignore __fpga_reg in emulation flow\012#ifdef HLS_X86\012  #define __fpga_reg(x) (x)\012#elif defined(__clang__)\012#if __has_builtin(__builtin_fpga_reg)\012  #ifndef __fpga_reg\012    #define __fpga_reg __builtin_fpga_reg\012  #endif\012#endif\012#endif\012\012namespace ihc {\012\012namespace internal {\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  size_t sim_base;\012\012protected:\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              int readwrite_mode, bool byteenabled, int maxburst, int align,\012              bool waitrequest, void *mem, size_t size, size_t data_size,\012              bool use_socket)\012      : aspace(aspace), awidth(awidth), dwidth(dwidth), latency(latency),\012        readwrite_mode(static_cast<readwrite_t>(readwrite_mode)),\012        byteenabled(byteenabled), maxburst(maxburst), align(align),\012        waitrequest(waitrequest), data_size(data_size), mem(mem), size(size),\012        use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              readwrite_t readwrite_mode, bool byteenabled, int maxburst,\012              int align, bool waitrequest);\012\012  void set_parameters(int aspace, int awidth, int dwidth, int latency,\012                      readwrite_t readwrite_mode, bool byteenabled,\012                      int maxburst, int align, bool waitrequest);\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() const {return aspace;}\012  void * get_base() const {return mem;}\012  size_t get_size() const {return size;}\012  int get_awidth() const {return awidth;}\012  int get_dwidth() const {return dwidth;}\012  int get_latency() const {return latency;}\012  readwrite_t get_readwrite_mode() const {return readwrite_mode;}\012  bool get_byteenabled() const {return byteenabled;}\012  int get_maxburst() const {return maxburst;}\012  int get_align() const {return align;}\012  bool get_waitrequest() const {return waitrequest;}\012  \012  size_t get_data_size() const {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base() {return sim_base;}\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() const {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, class ... Params>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012  std::queue<int> qpe_;\012#endif\012  \012protected:\012  stream();\012  \012#ifdef HLS_X86\012  stream(const stream<T,Params...>& copy_from);\012#endif\012  \012public:     \012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read();               \012  virtual void write(const T& arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop);\012  virtual T read(bool& sop, bool& eop, int& empty);\012  virtual void write(const T& arg, bool sop, bool eop);\012  virtual void write(const T& arg, bool sop, bool eop, int empty);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  virtual bool tryWrite(const T& arg, bool sop, bool eop);     \012  virtual bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(const T& arg);      \012  T tryRead(bool &success); \012  bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  T read(bool& sop, bool& eop, int& empty);\012  void write(const T& arg, bool sop, bool eop);\012  void write(const T& arg, bool sop, bool eop, int empty);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const T& arg, bool sop, bool eop);     \012  bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012   T _internal_cosim_front(bool& sop, bool& eop, int& empty);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void write_by_ptr_pkt_e(void *data, bool* sop, bool*eop, void* empty);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, class ... Params>\012  stream<T,Params...>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012#ifdef HLS_X86\012template <typename T, class ... Params>\012  stream<T,Params...>::stream(const stream<T,Params...>& copy_from):stream_abstract_base(sizeof(T)),q_(copy_from.q_),qp_(copy_from.qp_),qpe_(copy_from.qpe_)\012{\012}\012#endif\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, class ... Params>\012bool stream<T,Params...>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read(sop,eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read(sop,eop,empty);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read() {\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  T arg = q_.front();\012  q_.pop();\012\012  // unused sideband signals\012  qp_.pop();\012  qpe_.pop();\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop) {\012  T arg;\012\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  sop = p.first;\012  eop = p.second;\012\012  // unused sideband signals\012  qp_.pop();\012  qpe_.pop();\012\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, int& empty) {\012  T arg;\012\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty_) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  q_.pop();\012\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  // unused sideband signals\012  qp_.pop();\012  qpe_.pop();\012\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front() {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop, int& empty) {\012  T arg;      \012\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty_) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg, sop, eop);\012   }\012   return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop, int empty) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg, sop, eop, empty);\012   }\012   return success;\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg) {\012    q_.push(arg);\012\012    // sideband signals\012    qp_.push(std::pair<bool,bool>(false,false));\012    qpe_.push(0);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop) {\012    q_.push(arg);\012\012    // sideband signals\012    qp_.push(std::pair<bool,bool>(sop, eop));\012    qpe_.push(0);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop, int empty) {\012    q_.push(arg);\012\012    // sideband signals\012    qp_.push(std::pair<bool,bool>(sop, eop));\012    qpe_.push(empty);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = read(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = _internal_cosim_front(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    T elem;\012    int temp_empty;\012    memcpy(&elem, data, sizeof(T));\012    memcpy(&temp_empty, empty, sizeof(int));\012    write(elem, *sop, *eop, temp_empty);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012bool stream<T, Params...>::stall() {\012  if (m_remaining_period == 0) {\012    setStallPeriod();\012  }\012  m_remaining_period--;\012  if (m_remaining_period < m_period_threshold) { \012    return false;\012  } else {\012    return true;\012  }\012}\012\012template<typename T, class ... Params>\012unsigned stream<T, Params...>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#endif\012\012"}, {"path":"loop_pipeline2intel.cpp", "name":"loop_pipeline2intel.cpp", "has_active_debug_locs":false, "absName":"/home/u206862/loop_pipeline_vitis2intel/loop_pipeline2intel.cpp", "content":"#include \"HLS/hls.h\"\012/*\012 * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\012 * Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\012 *\012 * Licensed under the Apache License, Version 2.0 (the \"License\");\012 * you may not use this file except in compliance with the License.\012 * You may obtain a copy of the License at\012 *\012 *   http://www.apache.org/licenses/LICENSE-2.0\012 *\012 * Unless required by applicable law or agreed to in writing, software\012 * distributed under the License is distributed on an \"AS IS\" BASIS,\012 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\012 * See the License for the specific language governing permissions and\012 * limitations under the License.\012 */\012\012#include \"loop_pipeline2intel.h\"\012\012component dout_t loop_pipeline(din_t A[N]) {\012\012    int i, j;\012    static dout_t acc;\012\012LOOP_I:\012    for (i = 0; i < 20; i++) {\012    LOOP_J:\012        for (j = 0; j < 20; j++) {\012            acc += A[j] * i;\012        }\012    }\012\012    return acc;\012}\012"}, {"path":"loop_pipeline2intel.h", "name":"loop_pipeline2intel.h", "has_active_debug_locs":false, "absName":"/home/u206862/loop_pipeline_vitis2intel/loop_pipeline2intel.h", "content":"#include \"HLS/hls.h\"\012/*\012 * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\012 * Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\012 *\012 * Licensed under the Apache License, Version 2.0 (the \"License\");\012 * you may not use this file except in compliance with the License.\012 * You may obtain a copy of the License at\012 *\012 *   http://www.apache.org/licenses/LICENSE-2.0\012 *\012 * Unless required by applicable law or agreed to in writing, software\012 * distributed under the License is distributed on an \"AS IS\" BASIS,\012 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\012 * See the License for the specific language governing permissions and\012 * limitations under the License.\012 */\012\012#ifndef _LOOP_PIPELINE_H_\012#define _LOOP_PIPELINE_H_\012\012#include <fstream>\012#include <iostream>\012using namespace std;\012\012#ifdef __INTELFPGA_COMPILER__ \012#include \"HLS/ac_int.h\" \012#else \012#include \"ref/ac_int.h\" \012#endif\012#define N 20\012#define NUM_TRANS 20\012\012typedef ac_int<5,true> din_t;\012typedef ac_int<20,true> dout_t;\012\012dout_t loop_pipeline(din_t A[N]);\012\012#endif\012"}, {"path":"loop_pipeline_test2intel.cpp", "name":"loop_pipeline_test2intel.cpp", "has_active_debug_locs":false, "absName":"/home/u206862/loop_pipeline_vitis2intel/loop_pipeline_test2intel.cpp", "content":"#include \"HLS/hls.h\"\012/*\012 * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\012 * Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\012 *\012 * Licensed under the Apache License, Version 2.0 (the \"License\");\012 * you may not use this file except in compliance with the License.\012 * You may obtain a copy of the License at\012 *\012 *   http://www.apache.org/licenses/LICENSE-2.0\012 *\012 * Unless required by applicable law or agreed to in writing, software\012 * distributed under the License is distributed on an \"AS IS\" BASIS,\012 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\012 * See the License for the specific language governing permissions and\012 * limitations under the License.\012 */\012\012#include \"loop_pipeline2intel.h\"\012\012int main() {\012    din_t A[N];\012    dout_t accum;\012\012    int i, j, retval = 0;\012    ofstream FILE;\012\012    // Create input data\012    for (i = 0; i < N; ++i) {\012        A[i] = i;\012    }\012    // Save the results to a file\012    FILE.open(\"result.dat\");\012\012    // Call the function\012    for (j = 0; j < NUM_TRANS; ++j) {\012        accum = loop_pipeline(A);\012        FILE << accum << endl;\012        // New input data\012        for (i = 0; i < N; ++i) {\012            A[i] = A[i] + N;\012        }\012    }\012    FILE.close();\012\012    // Compare the results file with the golden results\012    retval = system(\"diff --brief -w result.dat result.golden.dat\");\012    if (retval != 0) {\012        cout << \"Test failed  !!!\" << endl;\012        retval = 1;\012    } else {\012        cout << \"Test passed !\" << endl;\012    }\012\012    // Return 0 if the test\012    return retval;\012}\012"}, {"path":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/math.h", "name":"math.h", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/intelFPGA_pro/18.1/hls/include/HLS/math.h", "content":"#ifndef __HLS_MATH_H__\012#define __HLS_MATH_H__\012\012/* This file is used to overlay math.h on linux and windows.\012The table below describes what is currently available on each platform\012We are currently supporting gcc 4.4.7 and MSVC 10 respectively, so that \012is the versions we are currenlty trying to mimic.\012All floating point functions that are available, has an f at the end for \012single precison floating point, so sin(double), but sinf(float)\012Y = Supported\012N = Not supported yet\012- = Not available on that platform with the supported underlying compiler, \012 ****************************************************************\012 * Function Name            Linux    Windows  Notes        *\012 * abs                          -    N        Integer math *\012 * labs                         -    N        Integer math *\012 * atof                         -    N                     *\012 * cos(float/double)            Y    Y                     *\012 * sin(float/double)            Y    Y                     *\012 * tan(float/double)            Y    Y                     *\012 * acos(float/double)           Y    Y                     *\012 * asin(float/double)           Y    Y                     *\012 * atan(float/double)           Y    Y                     *\012 * atan2(float/double)          Y    Y                     *\012 * cosh(float/double)           Y    Y                     *\012 * sinh(float/double)           Y    Y                     *\012 * tanh(float/double)           Y    Y                     *\012 * acosh(float/double)          N    N        C99/C++11    *\012 * asinh(float/double)          N    N        C99/C++11    *\012 * atanh(float/double)          N    N        C99/C++11    *\012 * exp(float/double)            Y    Y                     *\012 * frexp(float/double)          Y    Y                     *\012 * ldexp(float/double)          Y    Y                     *\012 * log(float/double)            Y    Y                     *\012 * log10(float/double)          Y    Y                     *\012 * modf(float/double)           Y    Y                     *\012 * exp2(float/double)           Y    Y        C99/C++11    *\012 * exp10(float/double)          Y    -                     *\012 * expm1(float/double)          Y    Y        C99/C++11    *\012 * ilogb(float/double)          Y    Y        C++11        *\012 * log1p(float/double)          D    D        C99/C++11    Only double supported* \012 * log2(float/double)           Y    Y        C99/C++11    *\012 * logb(float/double)           N    N        C++11        *\012 * scalbn(float/double)         N    N        C99/C++11    *\012 * scalbln(float/double)        N    N        C99/C++11    *\012 * pow(float/double)            Y    Y                     *\012 * sqrt(float/double)           Y    Y                     *\012 * cbrt(float/double)           Y    Y        C99/C++11    *\012 * hypot(float/double)          Y    Y        C99/C++11    *\012 * erf(float/double)            N    N        C99/C++11    *\012 * erfc(float/double)           N    N        C99/C++11    *\012 * tgamma(float/double)         N    N        C99/C++11    *\012 * lgamma(float/double)         N    N        C99/C++11    *\012 * ceil(float/double)           Y    Y                     *\012 * floor(float/double)          Y    Y                     *\012 * fmod(float/double)           Y    Y                     *\012 * trunc(float/double)          Y    Y        C++11        *\012 * round(float/double)          Y    Y        C++11        *\012 * lround(float/double)         N    N        C++11        *\012 * llround(float/double)        N    N        C++11        *\012 * rint(float/double)           Y    Y        C99/C++11    *\012 * lrint(float/double)          N    N        C++11        *\012 * llrint(float/double)         N    N        C++11        *\012 * nearbyint(float/double)      N    N        C++11        *\012 * remainder(float/double)      N    N        C++11        *\012 * drem                         N    -        obsolete name for remanider *\012 * remquo(float/double)         N    N        C++11        *\012 * significand                  N    -        non standard *\012 * copysign(float/double)       N    N        C99/C++11    *\012 * nan(float/double)            N    N        C99/C++11    *\012 * nextafter(float/double)      N    N        C99/C++11    *\012 * nexttoward(float/double)     N    N        C99/C++11    *\012 * fdim(float/double)           Y    Y        C++11        *\012 * fmin(float/double)           Y    Y        C++11        *\012 * fmax(float/double)           Y    Y        C++11        *\012 * fabs(float/double)           Y    Y                     *\012 * fma(float/double)            N    N        C++11        *\012 * fpclassify(float/double)     N    N        C++11        *\012 * isfinite(float/double)       Y    -        C++11        *\012 * finite                       Y    -        BSD name for isfinite _finite for windows    *\012 * isinf(float/double)          Y    -        C++11        *\012 * isnan(float/double)          Y    Y        C++11        *\012 * isnormal(float/double)       N    -        C++11        *\012 * signbit(float/double)        N    -        C++11        *\012 * isgreater(float/double)      N    -        C++11        *\012 * isgreaterequal(float/double) N    -        C++11        *\012 * isless(float/double)         N    -        C++11        *\012 * islessequal(float/double)    N    -        C++11        *\012 * islessgreater(float/double)  N    -        C++11        *\012 * isunordered(float/double)    N    -        C++11        *\012 ****************************************************************/\012\012#include <math.h>\012\012#if defined(__INTELFPGA_COMPILER__)\012#ifdef HLS_SYNTHESIS\012#define __PUREF __attribute__((const))\012\012// FPGA, remap to current internal OpenCL names\012extern \"C\" {\012\012/********** Supported trig builtins **********/\012double __PUREF __acl__cosfd(double __x);\012#define cos(__x) __acl__cosfd(__x)\012\012float __PUREF __acl__flush_denorm_cosf(float __x);\012#define cosf(__x) __acl__flush_denorm_cosf(__x)\012\012double __PUREF __acl__sinfd(double __x);\012#define sin(__x) __acl__sinfd(__x)\012\012float __PUREF __acl__flush_denorm_sinf(float __x);\012#define sinf(__x) __acl__flush_denorm_sinf(__x)\012\012double __PUREF __acl__wrapper_tanfd(double __x);\012#define tan(__x) __acl__wrapper_tanfd(__x)\012\012float __PUREF __acl__flush_denorm_tanf(float __x);\012#define tanf(__x) __acl__flush_denorm_tanf(__x)\012\012double __PUREF __acl__acosfd(double __x);\012#define acos(__x) __acl__acosfd(__x)\012\012float __PUREF __acl__flush_denorm_acosf(float __x);\012#define acosf(__x) __acl__flush_denorm_acosf(__x)\012\012double __PUREF __acl__asinfd(double __x);\012#define asin(__x) __acl__asinfd(__x)\012\012float __PUREF __acl__flush_denorm_asinf(float __x);\012#define asinf(__x) __acl__flush_denorm_asinf(__x)\012\012double __PUREF __acl__atanfd(double __x);\012#define atan(__x) __acl__atanfd(__x)\012\012float __PUREF __acl__flush_denorm_atanf(float __x);\012#define atanf(__x) __acl__flush_denorm_atanf(__x)\012\012double __PUREF __acl__atan2fd(double __x, double __y);\012#define atan2(__x, __y) __acl__atan2fd(__x, __y)\012\012float __PUREF __acl__atan2f(float __x, float __y);\012#define atan2f(__x, __y) __acl__atan2f(__x, __y)\012\012double __PUREF __acl__coshfd(double __x);\012#define cosh(__x) __acl__coshfd(__x)\012\012float __PUREF __acl__coshf(float __x);\012#define coshf(__x) __acl__coshf(__x)\012\012double __PUREF __acl__sinhfd(double __x);\012#define sinh(__x) __acl__sinhfd(__x)\012\012float __PUREF __acl__sinhf(float __x);\012#define sinhf(__x) __acl__sinhf(__x)\012\012double __PUREF __acl__tanhfd(double __x);\012#define tanh(__x) __acl__tanhfd(__x)\012\012float __PUREF __acl__tanhf(float __x);\012#define tanhf(__x) __acl__tanhf(__x)\012\012double __PUREF __acl__expfd(double __x);\012#define exp(__x) __acl__expfd(__x)\012\012float __PUREF __acl__flush_denorm_expf(float __x);\012#define expf(__x) __acl__flush_denorm_expf(__x)\012\012double __PUREF __acl_frexpd(double __x, int* __y);\012#define frexp(__x, __y)  __acl_frexpd(__x, __y)\012\012float __PUREF __acl_frexpf(float __x, int* __y);\012#define frexpf(__x, __y)  __acl_frexpf(__x, __y)\012\012double __PUREF __acl__ldexpfd(double __x, int __y);\012#define ldexp(__x, __y) __acl__ldexpfd(__x, __y)\012\012float __PUREF __acl__ldexpf(float __x, int __y);\012#define ldexpf(__x, __y) __acl__ldexpf(__x, __y)\012 \012double __PUREF __acl__logfd(double __x);\012#define log(__x) __acl__logfd(__x)\012\012float __PUREF __acl__flush_denorm_logf(float __x);\012#define logf(__x) __acl__flush_denorm_logf(__x)\012\012double __PUREF __acl__log10fd(double __x);\012#define log10(__x) __acl__log10fd(__x)\012\012float __PUREF __acl__log10f(float __x);\012#define log10f(__x) __acl__log10f(__x)\012\012double __PUREF __acl_modfd(double __x, double * __y);\012#define modf(__x, __y) __acl_modfd(__x, __y)\012\012float __PUREF __acl_modff(float __x, float* __y);\012#define modff(__x, __y) __acl_modff(__x, __y)\012\012double __PUREF __acl__exp2fd(double __x);\012#define exp2(__x) __acl__exp2fd(__x)\012\012float __PUREF __acl__exp2f(float __x);\012#define exp2f(__x) __acl__exp2f(__x)\012\012#if defined (__linux__)\012\012double __PUREF __acl__exp10fd(double __x);\012#define exp10(__x) __acl__exp10fd(__x)\012\012float __PUREF __acl__exp10f(float __x);\012#define exp10f(__x) __acl__exp10f(__x)\012\012#endif //linux\012\012inline double __x_expm1 (double __x) {\012  return __acl__expfd(__x) - 1.0;\012}\012#define expm1(__x) __x_expm1(__x)\012\012float __PUREF __acl__expm1f(float);      \012#define expm1f(__x) __acl__expm1f(__x)\012\012int __PUREF __acl__ilogbfd(double __x);\012#define ilogb(__x) __acl__ilogbfd(__x)\012\012int __PUREF __acl__ilogbf(float __x);\012#define ilogbf(__x) __acl__ilogbf(__x)\012\012double __PUREF __acl__ln1pxfd(double __x);\012#define log1p(__x) __acl__ln1pxfd(__x)\012\012double __PUREF __acl__log2fd(double __x);\012#define log2(__x) __acl__log2fd(__x)\012\012float __PUREF __acl__log2f(float __x);\012#define log2f(__x) __acl__log2f(__x)\012\012\012\012double __PUREF __acl__powfd(double __x, double __y);\012#define pow(__x,__y) __acl__powfd(__x, __y)\012\012float __PUREF __acl__powf(float __x, float __y);\012#define powf(__x,__y) __acl__powf(__x, __y)\012\012double __PUREF __acl__sqrtfd(double  __x);\012#define sqrt(__x) __acl__sqrtfd(__x)\012\012float __PUREF __acl__flush_denorm_sqrtf(float __x);\012#define sqrtf(__x) __acl__flush_denorm_sqrtf(__x)\012\012// Only have the float version built-in.\012inline double __x_cbrt(double __x) {\012  return exp(log(__x) / 3.0);\012}\012#define cbrt(__x) __x_cbrt(__x)\012\012float __PUREF __acl__cbrtf(float);\012#define cbrtf(__x) __acl__cbrtf(__x)\012\012\012inline double __x_hypot(double __x, double __y) {\012  return sqrt(__x*__x + __y*__y);\012}\012#define hypot(__x,__y) __x_hypot(__x,__y)\012\012\012float __PUREF __acl__hypotf(float, float);\012#define hypotf(__x,__y) __acl__hypotf(__x,__y)\012\012/************ Error & Gamma Functions *********/\012double __PUREF __acl__ceilfd(double __x);\012#define ceil(__x) __acl__ceilfd(__x)\012\012float __PUREF __acl__ceilf(float __x);\012#define ceilf(__x) __acl__ceilf(__x)\012\012double __PUREF __acl__floorfd(double __x);\012#define floor(__x) __acl__floorfd(__x)\012\012float __PUREF __acl__floorf(float __x);\012#define floorf(__x) __acl__floorf(__x)\012\012double __PUREF __acl__fmodfd(double __x, double __y);\012#define fmod(__x,__y) __acl__fmodfd(__x, __y)\012\012float __PUREF __acl__fmodf(float __x, float __y);\012#define fmodf(__x,__y) __acl__fmodf(__x, __y)\012\012double __PUREF __acl__truncfd(double __x);\012#define trunc(__x) __acl__truncfd(__x)\012\012float __PUREF __acl__truncf(float __x);\012#define truncf(__x) __acl__truncf(__x)\012\012double __PUREF __acl__roundfd(double __x);\012#define round(__x) __acl__roundfd(__x)\012\012float __PUREF __acl__roundf(float __x);\012#define roundf(__x) __acl__roundf(__x)\012\012double __PUREF __acl__rintfd(double __x);\012#define rint(__x) __acl__rintfd(__x)\012\012float __PUREF __acl__rintf(float __x);\012#define rintf(__x) __acl__rintf(__x)\012\012double __PUREF __acl__fdimfd(double __x, double __y);\012#define fdim(__x,__y) __acl__fdimfd(__x, __y)\012\012float __PUREF __acl__fdimf(float __x, float __y);\012#define fdimf(__x,__y) __acl__fdimf(__x, __y)\012\012double __PUREF __acl__fminfd(double __x, double __y);\012#define fmin(__x,__y) __acl__fminfd(__x, __y)\012\012float __PUREF __acl__fminf(float __x, float __y);\012#define fminf(__x,__y) __acl__fminf(__x, __y)\012\012double __PUREF __acl__fmaxfd(double __x, double __y);\012#define fmax(__x,__y) __acl__fmaxfd(__x, __y)\012\012float __PUREF __acl__fmaxf(float __x, float __y);\012#define fmaxf(__x,__y) __acl__fmaxf(__x, __y)\012\012double __PUREF __acl__fabsfd(double __x);\012#define fabs(__x) __acl__fabsfd(__x)\012\012float __PUREF __acl__fabsf(float __x);\012#define fabsf(__x) __acl__fabsf(__x)\012\012/********** Classification ******************/\012#if defined (__linux__)\012long __PUREF __acl__isfinitefd(double __x);\012#define __finite(__x) __acl__isfinitefd(__x)\012\012int __PUREF __acl__isfinitef(float __x);\012#define __finitef(__x) __acl__isfinitef(__x)\012\012#define finite(__x) __acl__isfinitefd(__x)\012#define finitef(__x) __acl__isfinitef(__x)\012\012long __PUREF __acl__isinffd(double __x);\012#define __isinf(__x) __acl__isinffd(__x)\012\012int __PUREF __acl__isinff(float __x);\012#define __isinff(__x) __acl__isinff(__x)\012\012long __PUREF __acl__isnanfd(double __x);\012#define __isnan(__x) __acl__isnanfd(__x)\012\012int __PUREF __acl__isnanf(float __x);\012#define __isnanf(__x) __acl__isnanf(__x)\012\012#endif //linux\012\012#if defined (_MSC_VER)\012  // Pull in CPP Library version information. \012  long __PUREF __acl__isnanfd(double __x);\012\012  int __PUREF __acl__isnanf(float __x);\012  \012  #if (_CPPLIB_VER >= 650)\012    // Support isnan(x) for MSVC 2015+  in fpga components.\012    #ifndef isnan \012      #define isnan(x) \\\012        (sizeof (x) == sizeof (float) ? __acl__isnanf(x) :  __acl__isnanfd(x))\012    #endif // #ifndef isnan\012\012  #endif // #if (_CPPLIB_VER >= 650)\012  // MSVC handles _isnanf and _isnanfd in 2 different places (math.h and float.h)\012  // So it is messy to support them. Use isnan instead.\012\012#endif // #if defined(MSC_VER)\012\012\012\012}\012#endif //#ifdef HLS_SYNTHESIS\012#endif //__INTELFPGA_COMPILER__\012#endif //__HLS_MATH_H__\012\012"}];